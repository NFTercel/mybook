{"./":{"url":"./","title":"前言","keywords":"","body":"my-book study books begin By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第一章/":{"url":"第一章/","title":"第一章","keywords":"","body":"第一章 接口基础 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第一章/课程简介&接口测试概述.html":{"url":"第一章/课程简介&接口测试概述.html","title":"第1节：课程简介&接口测试概述","keywords":"","body":"第1节：课程简介&接口测试概述 课程背景 在测试金字塔模型中分为三层：最底层是单元测试，中间层接口测试，最顶层为 UI 测试。接口测试位于第二层。 接口一般比较稳定，因此接口测试的效益最大,同时接口测试可以跨应用：Web/App 跨平台：Win，Mac,Liunx 等。本套课程中将会针对接口的基本理论，HTTP 协议、接口测试工具、Python 接口性能自动化测试来进行综合 讲解，让大家全面掌握接口自动化测试。 内容概要 接口基础知识 HTTP协议基础原理 接口测试工具使用 接口性能自动化测试 Restful接口开发测试 Python + Requests接口测试 接口Mock Server 课程目标 掌握接口测试理论方法 掌握接口测试工具使用 掌握 HTTP 协议 独立编写 Python 接口测试脚本 独立完成接口性能自动化测试 熟悉 Restful 接口开发与调试 学习建议 有问题上自学网问答平台:http://wen.51zxw.net，不建灌水斗图吐槽群 遇到问题多谷歌，打不开？谷歌镜像站:https://guge3.bban.top/ 下载自学网 APP 移动学习，各大应用市场均可下载。 留言打卡学习，见证学习成长轨迹。 夯实语言基础：Pyhotn 保持专注，排除干扰, 推荐 GTD 番茄学习法 什么是接口？ API API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与 开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 举例说明： 笔记本电脑上提供了各种物理硬件接口，比如 USB 接口，耳机接口、麦克风接口、电源接口等.... 这些不 同的接口有不同的功能：比如通过 USB 接口插入 U 盘就可以拷贝电脑数据，插入耳机接口可以听音乐，我 们无需关心这些接口的工作原理，只需通过这些接口满足我们的使用需求即可。 在中国天气网网上查询某个城市天气，主要输入城市名称，即可获取到对应的天气。查询背后的本质也是 调用了网站后台接口来获取数据，这里的接口是 Web 服务软件接口。用户不需要关注数据在网站后台是怎 么查询的，只需要返回一个结果即可。 开放平台 基于互联网的应用正变得越来越普及，在这个过程中，有更多的站点将自身的资源开放给开发者来调用。对外提供 的 API 调用使得站点之间的内容关联性更强，同时这些开放的平台也为用户、开发者和中小网站带来了更大的价值。 气象大数据交易平台 微信开放平台 接口测试 什么是接口测试？ 接口测试是对系统或组件之间的接口进行测试，主要是校验数据的交换，传递和控制管理过程，以及相互逻辑依赖 关系。其中接口协议分为 HTTP,WebService,Dubbo,Thrift,Socket 等类型，本套课程主要是针对 HTTP 类型接口来进行 讲解。测试类型又主要分为功能测试，性能测试，稳定性测试，安全性测试等。 为什么要做接口测试？ 接口测试实施在多系统的平台架构下，有着极为高效的成本收益比（当然，单元测试收益更高，但实施单元测试的 成本投入更大，技术要求更高）。 接口测试天生为高复杂性的平台带来高效的缺陷检测和质量监督能力，平台复杂，系统越庞大，接口测试的效果越 明显。 接口测试优势主要体现在如下三个方面： 1、节省了测试成本 根据数据模型推算，底层的一个程序 BUG 可能引发 UI 层的 8 个左右 BUG，而且底层的 BUG 更容易引起全网的死 机；接口测试能够提供系统复杂度上升情况下的低成本高效率的解决方案。 2、接口测试门槛相对较低 接口测试不同于单元测试，接口测试是站在用户的角度对系统接口进行全面高效持续的检测。 3、效益更高 将接口测试实现为自动化和持续集成，当系统复杂度和体积越大，接口测试的成本就越低，相对应的，效益产出就 越高。 怎么样去做接口测试？ 基本的接口功能自动化测试流程如下： 需求分析 -> 用例设计 -> 脚本开发 -> 测试执行 -> 结果分析 需求分析 需求分析是参考需求、设计等文档，在了解需求的基础上还需清楚内部的实现逻辑，并且可以在这一阶段提出需求、 设计存在的不合理或遗漏之处。 用例设计 用例设计是在理解接口测试需求的基础上，使用 Excel 或 XMind 等思维导图软件编写测试用例设计，主要内容包括 参数校验，功能校验、业务场景校验、安全性及性能校验等，常用的用例设计方法有等价类划分法，边界值分析法， 场景分析法，因果图，正交表等。 脚本开发 使用自己熟悉的语言或者工具来开发即可。 测试执行 可以直接运行接口测试脚本或者使用 CI 来执行测试 结果分析 根据测试报告来分析接口测试结果。 参考资料 https://baike.baidu.com/item/接口/2886384?fr=aladdin https://blog.csdn.net/lovesoo/article/details/78558303?locationNum=9&fps=1 https://www.cnblogs.com/imyalost/p/7430126.html https://testerhome.com/topics/11051 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第一章/HTTP协议基础.html":{"url":"第一章/HTTP协议基础.html","title":"第2节：HTTP协议基础","keywords":"","body":"第2节：HTTP协议基础 HTTP 简介 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。HTTP 协议在网 络 OSI 模型中属于应用层协议，应用层协议除了 HTTP 还有：FTP，SMTP，DNS，RIP，Telnet 等。 HTTP 协议工作于客户端—服务端架构上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端（即 Web 服务器） 发送请求。 扩展资料：计算机网络教程 超文本 超文本英文名称叫做 Hypertext，我们在浏览器里面看到的网页就是超文本解析而成的，其网页源代码是一系 列 HTML 代码，里面包含了一系列标签，如 img 显示图片，p 指定显示段落等，浏览器解析这些标签后便形成了我们 平常看到的网页，而这网页的源代码 HTML 就可以称作超文本。 例如我们在 Chrome 浏览器里面打开如百度页面，右键点击\"查看源代码\"，这些源代码都是超文本。 URL URL 我们在浏览器的地址栏里输入的网站地址叫做 URL (Uniform Resource Locator，统一资源定位符)。就像每家每 户都有一个门牌地址一样，每个网页也都有一个 Internet 地址（如：http://www.51zxw.net）。当你在浏览器的 地址框中输入一个 URL 或是单击一个超级链接时，URL 就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)， 将 Web 服务器上站点的网页代码提取出来，并翻译成漂亮的网页。 HTTP 功能 HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从服务器传输超文本到本地浏览器的传输协 议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档 中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP 特点 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后， 即断开连接。采用这种方式可以节省传输时间。 媒体独立：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 来传输。 详见：MIME 参考手册 无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。如果服务器不需要先前信 息，那么它的应答就比较快。但是缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可 能导致每次连接传送的数据量增大，此时可以设置缓存。 HTTP 与 HTTPS 现在在浏览很多网站时，通过浏览器地址栏可以看到有的网站是 https 开头（https://www.baidu.com/ ）, 但是 有的是 http 开头（如：http://www.weather.com.cn >）这两种有什么区别呢？难道加了 s 就是复数吗？ HTTPS 的全称是 Hyper Text Transfer Protocol over Secure Socket Layer，是以安全为目标的 HTTP 通道， 简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层（Secure Sockets Layer 安全套接层），简称为 HTTPS。 S 其实是 Security 单词的首字母。HTTPS 的安全基础是 SSL，因此通过它传输的内容都是经过 SSL 加密的，它的主要作用可以分为两种： 是建立一个信息安全通道，来保证数据传输的安全。 确认网站的真实性，凡是使用了 https 的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之 后的真实信息，也可以通过 CA 机构颁发的安全签章来查询。 现在越来越多的网站和 APP 都已经向 HTTPS 方向发展。例如：谷歌从 2017 年 1 月推出的 Chrome 56 开始， 对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户“此网页不安全”。 HTTP 与 TCP/IP 的区别 TCP/IP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协议，主要解决如何包装数据。 关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层） TCP/IP 协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使 用到应用层协议，应用层协议有很多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议。WEB 使用 HTTP协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上。” HTTP 请求过程 我们在浏览器输入百度首页的地址：https://www.baidu.com/ 输入之后浏览器会给我们打开百度首页。实际上这 个过程是浏览器向网站所在的服务器发送了一个 Request，即请求，网站服务器接收到这个 Request 之后进行处 理和解析，然后返回对应的一个 Response，即响应，然后传回给浏览器，Response 里面就包含了页面的源代码 等内容，浏览器再对其进行解析便将网页呈现了出来。 此处打开浏览器，按 F12 演示内容 Request Request，即请求，由客户端向服务端发出。可以将 Request 划分为四部分内容： Request Method: 请求方式 Request URL: 请求链接 Request Headers: 请求头 Request Body: 请求体 Request Method 请求方式，请求方式常见的有两种类型，GET 和 POST。 GET 用于信息获取，而且应该是安全的和幂等的(幂等的的意思就是一个操作不会修改状态信息，并且每次 操作的时候都返回同样的结果。) 从发送请求的角度，GET 请求相当于我们在数据库中做了查询的操作， 这样的操作不影响数据库本身的数据。 POST 表示可能会修改服务器上资源的请求，也相当于在数据库中做了修改的操作，会影响数据库本身的 数据（比如：注册了账户，发了帖子，做了评论，得到了积分等。这种情况下，资源状态被改变了）。 案例 1——GET 请求 在浏览器输入：https://www.baidu.com/s?wd=appium 并回车，这个其实就是在百度搜索 appium 这个关键词。URL 中 包含了请求的参数信息，这里参数 wd 就是要搜寻的关键字。在浏览器可以看到 Query String Parameters 选项就是 请求的参数。发起一次 GET 请求时，参数会以 url string 的形式进行传递。即?后的字符串则为其请求参数，并以& 作为分隔符。 案例 2——POST 请求 一般来说，网站登录验证的时候，需要提交用户名密码，这里包含了敏感信息，使用 GET 方式请求的话密码就会 暴露在 URL 里面，造成密码泄露，所以这里最好以 POST 方式发送。文件的上传时，由于文件内容比较大，也会 选用 POST 方式。比如百度账户登录，如下图所示： 除了常规的 GET，POST 请求，另外还有一些请求方式，如 HEAD、PUT、DELETE 等，简单将其总结如下： 方法 描述 GET 请求指定的页面信息,并返回实体主体. POST 向指定资源提交数据进行处理请求,数据被包含在请求体中. PUT 从客户端向服务器传送的数据取代指定的文档的内容. PATCH 对PUT方法的补充,用来对已知资源进行局部更新 DELETE 请求服务器删除指定的页面. HEAD 类似于GET请求,只不过返回的响应中没有具体的内容,用于获取报头 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 OPTIONS 允许客户端査看服务器的性能. TRACE 回显服务器收到的请求,主要用于测试或诊断. Request URL Request URL就是请求的网址,即统一资源定位符,用URL可以唯一确定我们想请求的资源。比如:https://www.baidu.com/ Request Headers 请求头,用来说明服务器要使用的附加信息,比较重要的信息有 Cookie、 Referer、 User-Agent等,下面将一些常用的头信息说明如下: Accept,请求报头域,用于指定客户端可接受哪些类型的信息. Accept- Language,指定客户端可接受的语言类型 Accept- Encoding,指定客户端可接受的内容编码. Host,用于指定请求资源的主机丨P和端口号,其内容为请求∪RL的原始服务器或网关的位置.从HTTP 1.1版本开始, Request必须包含此内容 Cookie,也常用复数形式 Cookies,是网站为了辨别用户进行 Session跟踪而储存在用户本地的数据. Cookies的主要功能就是维持当前访问会话. Referer,此内容用来标识这个请求是从哪个页面发过来的,服务器可以拿到这一信息并做相应的处理,如做来源统计、做防盗链处理等. User- Agent,简称UA,它是一个特殊字符串头,使得服务器能够识别客户使用的操作系统及版本、浏览器及版本等信息.在做爬虫时加上 此信息可以伪装为浏览器,如果不加很可能会被识别出为爬虫. Content-Type,即 Internet Media Type,互联网媒体类型,也叫做MME类型,在HTP协议消息头中,使用它来表示具体请求中的媒体类型信息. 例如 application/x-w-form- urlencode表示表单数据,text/htm代表HTML格式, image/gif代表G|F图片, application/json代表Json类型 Request Body 即请求体,一般用于POST请求中,主要定义向服务器提交的数据类型,而对于GET请求 Request Body则为空。 比如在登录之前我们填写了用户名和密码信息,提交时就这些内容就会以Formυata的形式提交给服务器,此时注意 Request Headers中指定了 Content-Type为 application/x-w-form- urlencode,只有设置 Content-Type为 application/x-wwx-form- urlencode才会以 Form Data形式提交, 另外我们也可以将 Content-Type设置为 application/json来提交Json数据,或者设置为 multipart/form-data来上传文件。 常用 Content-ype和POST提交数据方式的关系： Content-Type 提交数据方式 application/x-www-form-urlencoded Form表单提交 multipart/form-data 表单文件上传提交 application/json 序列化Json数据提交 text/xml XML数据提交 application/x-Www- form-urlencoded与 multipart/form-data区别 在没有 typeafile时候,用默认的 application/x-w-form- urlencode就行。 在有type=file时候,要用 multipart/form-data编码方式.浏览器会把表单以控件为单位分割,并且为每个部分加上 Content- Dispositon(form-data或fie)、 Content-Type(默认text/ plain)、name(控件name)等信息,并加上分割符( boundary)。 ​ Response Response,即响应,由服务端返回给客户端. Response可以划分为三部分： Response Status Code Response Headers Response Body Response Status Code 响应状态码,此状态码表示了服务器的响应状态,如200则代表服务器正常响应,404则代表页面未找到,500则代表服务器内部发生错误.常用响应状态码如下： 状态码 说明 详情 200 成功 服务器已成功处理了请求. 201 已创建 请求成功并且服务器创建了新的资源 301 永久移动 请求的网页已永久移动到新位置,即永久重定向 302 临时移动 请求的网页暂时跳转到其他页面,即暂时重定向. 400 错误请求 服务器无法解析该请求 401 未授权 请求没有进行身份验证或验证未通过. 403 禁止访问 服务器拒绝此请求。 404 未找到 服务器找不到请求的网页。 500 服务器内部错误 服务器不具备完成请求的功能。 501 未实现 服务器不具备完成请求的功能。 502 错误网关 服务器作为网关或代理,从上游服务器收到无效响应。 扩展资料:HTTP响应码 Response Headers 响应头,其中包含了服务器对请求的应答信息,如 Content-Type、 Server、 Set-Cookie等,下面将一些常用的信息说明如下: Date,标识 Response产生的时间。 Last- Modified,指定资源的最后修改时间。 Content- Encoding,指定 Response内容的编码Server,包含了服务器的信息,名称,版本号等。 Content-Type,文档类型,指定了返回的数据类型是什么,如text/htm则代表返回HTML文档application/ X-Javascript则代表返回 JavaScript文件, Image/jpeg则代表返回了图片。 Set- Cookie,设置 Cookie, Response Headers中的 Set-Cookie即告诉浏览器需要将此内容放在Cookies中,下次请求携带 Cookies内容。 Expires,指定 Response的过期时间,使用它可以控制代理服务器或浏览器将内容更新到缓存中,如果再次访问时,直接从缓存中加载,降低服务器负载,缩短加载时间。 Response Body 即响应体,响应的正文数据都是在响应体中,如请求一个网页,它的响应体就是网页的HTML代码,请求一张图片,它的响应体就是图片的二进制数据。 一般在接口的响应内容大多都是Json数据内容。 参考资料 https://baike.baidu.com/item/http/243074?fr=aladdin#2 https://germey.gitbooks.io/python3webspider/content/2.1-HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html https://www.cnblogs.com/duanxz/p/5127561.html By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第一章/JSON数据.html":{"url":"第一章/JSON数据.html","title":"第3节：JSON数据","keywords":"","body":"第3节：JSON数据 JSON简介 JSON( JavaScript Object Notation,即 JavaScript对象表示法)是一种轻量级的数据交换格式。它独立于语言和平台,JSON解析器和JSON库支持不同的编程语言。 JSON具有自我描述性,很容易理解.目前大多数接口返回的数据格式为JSON,因此进行接口测试必须掌握JSON JSON语法 语法规则 数据在键/值对中 数据由逗号分隔 {花括号}保存对象 [方括号]保存数组 JSON键/值对 JSON数据的书写格式是:key: value键值对。比如: “Name”：\"512xW\" JSON值可以是： 数字(整数或浮点数) 字符串(在双引号中) 逻辑值(true或 false) 数组(在方括号中) 对象(在花括号中) JSON数字 \"status code\": 200 JSON字符串 \"Name\":\"51zxw\" JSON逻辑值 \"result\" : true JSON数组 \"user\":[\"51zxw\",\"zxw2818\",\"zXw666\"] JSON对象 JSON对象在花括号中书写:对象可以包含多个键/值对: { \"firstName\":\"John\",\"lastName\":\"Doe\"} Tips:在接口测试过程中,一般都是返回JsON对象类型。 JSON数据嵌套 比如在数组中含多个对象: { \"employees\":[ {\"firstName\":\"John\",\"lastName\":\"Doe\"}, {\"firstName \": \"Anna\",\"lastName\": Smith\"}, {\"firstName\":\"Peter\",\"lastName\":\"Jones\"} ] } 在上面的例子中,对象\" employees\"是包含三个对象的数组.每个对象代表条关于某人(有姓和名)的记录。 JSON数据解析 Python3中可以使用json模块来对JSoN数据进行编解码,它包含了两个方法: json. dumps():将 python数据转化为Json数据 json. loads():将json数据类型转为 Python数据类型 JSON库官方文档https://docs.python.org/3/library/json.html json.dumps() 将 python数据转化为Json数据 json_ dumps.py import json data={'id': 1, 'name':'51zxw','password':'66666'} print (type(data)) json_str=json.dumps(data) print(type (ison_str) print(json_str) 输出结果： {\"password\":\"66666\",\"id\": 1,\"name\":“51Zxw\") json.loads() 将json数据类型转为 Python数据类型 json_loads.py import json json_str='{\"id\": 1,\"name\":\"51zxw\",\"password\": \"66666\"}' data=json.loads(json_str) print(type(json_str)) print(type(data) print(data) print(data[ 'id']) print(data['name']) 输出结果: {'name':'51zxw','password':'66666','id':1) 1 51zxw Json文件处理 有时我们可能需要将JSON数据写入到文件,或者从Json数据文件读取数据 #写入JSON数据到文件 with open('data. json',w) as f: json, dump(data, f) #读取JSON数据文件 with open('data.json' ,'r') as f: data= json. load(f) 参考资料 https://www.w3school.com.cn/json/index.asp https://www.runoob.com/python3/python3-json.html By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第二章/":{"url":"第二章/","title":"第二章","keywords":"","body":"第二章 接口工具 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第二章/Postman教案.html":{"url":"第二章/Postman教案.html","title":"第1节：Postman教案","keywords":"","body":"第1节：Postman教案 Postman简介 一般简单的接口测试我们可以直接在浏览器里面进行调试,但是涉及到一些权限设置的就无法操作了,因此我们需要接口测试的相关工具 Postman是一个接口测试和http请求的工具。 官网地址:https://www.getpostman.com/ Postman的优点: 支持各种的请求类型:get、post、put、 patch、 delete等 支持在线存储数据,通过账号就可以进行迁移数据 很方便的支持请求 header和请求参数的设置支持不同的认证机制,包括 Basic Auth, Digest Auth, OAuth1.0, OAuth2.0等 响应数据是自动按照语法格式高亮的,包括HTML,JSON和XML ​ 下载安装 Postman有 windows,Mac、 Liunx以及 Chrome插件版本.这里主要介绍Wn平台版本的使用。 下载地址:https://www.getpostman.com/downloads/ 官方文档https://www.getpostman.com/docs/v6 PostmanApi文档:https://docs.postman-echo.com ​ Postman 入门 安装好之后启动程序,进入主界面.准备开始使用 Postman 发送第一个请求 启动软件后在引导界面点击 Request,给 Request命名然后创建文件夹并把该 Request归属到该文件夹 在地址栏输λ入http://postman-echo.com/get然后点击Send按钮,可以看到返回值.如下图所示: Postman工作原理 如下图所示,当您在 Postman中输入请求并单击Send按钮时,服务器将接收您的请求并返回 Postman在接口中显示的响应。 Request编辑 在主界面左侧可以查看、保存、编辑 Request。 发送不同类型HTTP请求 GET HTTP GET请求方法用于从服务器检索数据。数据由唯一的URI(统一资源标识符)标识。 GET请求可以使用\" Query String Parameters\"将参数传递给服务器。例如,在下面的请求中, https://postman-echo.com/get?param1=51zxw&param2=66666 请求说明 param1和 paran2表示发送的参数。 ？后面接参数 &连接多个参数 参数编辑 点击 Params按钮, Postman可以自动帮我们解析出对应参数。 如果想要暂时不传参数,可以方便的通过不勾选的方式去实现 如果想要批量的编辑参数,可以点击右上角的 Bulk edit,去实现批量编辑 响应数据 在主界面下方一栏菜单为响应菜单栏,可以查看响应内容, Cookie、 Headers、响应状态码等信息。 返回值: { \"args\": { \"param1\": \"51zxw\", \"param2\": \"66666\" }, \"headers\": { \"x-forwarded-proto\": \"https\", \"host\": \"postman-echo.com\", \"accept\": \"*/*\", \"accept-encoding\": \"gzip, deflate\", \"cache-control\": \"no-cache\", \"content-type\": \"application/x-www-form-urlencoded\", \"cookie\": \"sails.sid=s%3ASuu380VNynx7t2iIbZ9kPtjU2k_OyZa8.O22iwzrXgNqEa%2BwqnJWtk3%2BDJ6H8A8l8cOU1tq64ta8\", \"postman-token\": \"69dd9cbe-fd85-46f1-a74c-57f6f4bc2c52\", \"user-agent\": \"PostmanRuntime/7.6.0\", \"x-forwarded-port\": \"443\" }, \"url\": \"https://postman-echo.com/get?param1=51zxw&param2=66666\" } POST HTTP POST请求方法旨在将数据传输到服务器,返回的数据取决于服务器的实现.POST请求可以使用 Query String Parameters以及body将参数传递给服务器。 案例1 在下面的请求中,使用 Query String Parameters传递参数。 https://postman-echo.com/post?param=51zxw 返回值 { \"args\": { \"param\": \"51zxw\" }, \"data\": \"\", \"files\": {}, \"form\": {}, \"headers\": { \"x-forwarded-proto\": \"https\", \"host\": \"postman-echo.com\", \"content-length\": \"0\", \"accept\": \"*/*\", \"accept-encoding\": \"gzip, deflate\", \"cache-control\": \"no-cache\", \"content-type\": \"application/x-www-form-urlencoded\", \"cookie\": \"sails.sid=s%3ASuu380VNynx7t2iIbZ9kPtjU2k_OyZa8.O22iwzrXgNqEa%2BwqnJWtk3%2BDJ6H8A8l8cOU1tq64ta8\", \"postman-token\": \"43f4f7a1-f009-4d6c-ac29-817301d4b329\", \"user-agent\": \"PostmanRuntime/7.6.0\", \"x-forwarded-port\": \"443\" }, \"json\": null, \"url\": \"https://postman-echo.com/post?param=51zxw\" } 案例2 发送一个 Request,其中body为 application/x-w-form- urlencode类型,参数分别为 param1=zxw和 param2=88请求URL如下: https://postman-echo.com/post Postman Body数据类型说明: form- data multipart/form-data是web表单用于传输数据的默认编码.这模拟了在网站上填写表单并提交它。表单数据编辑器允许我们为数据设置键-值对。 我们也可以为文件设置一个键,文件本身作为值进行设置 x-www-form- urlencode该编码与URL参数中使用的编码相同.我们只需输入键-值对, Postman会正确编码键和值.请注意,我们无法通过此编码模式上传文件。 表单数据和 urlencode些差异,因此请务必首先检査AP的编码实现,确定是否可以使用这种方式发送请求。 raw请求可以包含任何内容.除了替换环境变量之外, Postman不触碰在编辑器中输入的字符串。无论你在编辑区输λ什么内容,都会随请求一起发送到服务器。 编辑器允许我们设置格式类型以及使用原始主体发送的正确请求头.我们也可以手动设置 Content-τype标题,这将覆盖 Postman定义的设置。 binary二进制数据可让我们发送 Postman中无法输入的内容,例如图像,音频或视频文件。 返回值如下： { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"param1\": \"zxw\", \"param2\": \"888\" }, \"headers\": { \"x-forwarded-proto\": \"https\", \"host\": \"postman-echo.com\", \"content-length\": \"21\", \"accept\": \"*/*\", \"accept-encoding\": \"gzip, deflate\", \"cache-control\": \"no-cache\", \"content-type\": \"application/x-www-form-urlencoded\", \"cookie\": \"sails.sid=s%3Af7j_I2DXNkNPWBUVT9XT2mZ0-AXvAcp1.Z%2FHWGX4aUsEJD1qrPrcKIWdEXOoraOawijr5WR%2BQW%2B0\", \"postman-token\": \"93ee3c1a-305e-4c0a-91d5-5cf73d0f601f\", \"user-agent\": \"PostmanRuntime/7.6.0\", \"x-forwarded-port\": \"443\" }, \"json\": { \"param1\": \"zxw\", \"param2\": \"888\" }, \"url\": \"https://postman-echo.com/post\" } PUT HTTP PUT请求主要是从客户端向服务器传送的数据取代指定的文档的内容。 PUT请求可以使用 Query String Parameters以及body请求体将参数传递给服务器。 案例: 发送PUT请求,并传递字符参数\"helo51zXW\" https://postman-echo.com/put 返回值 { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"hello 51zxw\": \"\" }, \"headers\": { \"x-forwarded-proto\": \"https\", \"host\": \"postman-echo.com\", \"content-length\": \"11\", \"accept\": \"*/*\", \"accept-encoding\": \"gzip, deflate\", \"cache-control\": \"no-cache\", \"content-type\": \"application/x-www-form-urlencoded\", \"cookie\": \"sails.sid=s%3Akd-YyMn-jyqjGjB4Nr5QJdiB9EnB9YC5.kncHO6eRd5CzskO2O80q9mmBPSspnyMJUHl9eOFwXV0\", \"postman-token\": \"042d9f8e-e733-4c10-bd7c-533b2612bd95\", \"user-agent\": \"PostmanRuntime/7.6.0\", \"x-forwarded-port\": \"443\" }, \"json\": { \"hello 51zxw\": \"\" }, \"url\": \"https://postman-echo.com/put\" } DELETE HTTP DElETE方法用于删除服务器上的资源, DELETE请求可以使用 Query String Parameters以及body请求体将参数传递给服务器。delete请求 https://postman-echo.com/delete 返回值 { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": {}, \"headers\": { \"x-forwarded-proto\": \"https\", \"host\": \"postman-echo.com\", \"accept\": \"*/*\", \"accept-encoding\": \"gzip, deflate\", \"cache-control\": \"no-cache\", \"content-type\": \"application/x-www-form-urlencoded\", \"cookie\": \"sails.sid=s%3AH98u5xdFDmcdwALUeuzPIDIwtw0BDDJg.E6fm%2FbBoe%2BgNKiUFNO%2Fhq4N9cOsdoAYpGtt54o1g6Zs\", \"postman-token\": \"339baf8e-85ee-406e-a552-455e251358f4\", \"user-agent\": \"PostmanRuntime/7.6.0\", \"x-forwarded-port\": \"443\" }, \"json\": null, \"url\": \"https://postman-echo.com/delete\" } Request Header Request Header(请求头)用来说明服务器要使用的附加信息,比较重要的信息有 Cookie、 Referer、User- Agent等。 在 Postman中可以在请求下方的 Headers栏目来设置,如下如图所示： Response Header Response Header（响应头)其中包含了服务器对请求的应答信息,如 Content-Type、 Server、 Set-Cookie等, 在 Postman主界面下方 Headers或者 Postman Console界面都可以查看 Response Header信息。 Tps:通过 Postman Console可以看到每次请求的 Request Header详细信息,详见视频演示。 授权设置 很多时候,出于安全考虑我们的接口并不希望对外公开。这个时候就需要使用授权( Authorization)机制授权过程验证您是否具有访问服务器所需数据的权限。 当您发送请求时,您通常必须包含参数,以确保请求貝有访问和返回所需数据的权限。Postman提供授权类型,可以轻松地在 Postman本地应用程序中处理身份 验证协议Postman支持的授权协议类型如下： No Auth Bearer Token Basic auth Digest Auth OAuth 1.0 OAuth 2.0 Hawk Authentication AWS Signature NTLM Authentication [Beta] 这里主要介绍以上加粗的授权协议的使用。 Basic auth 基本身份验证是一种比较简单的授权类型,需要经过验证的用户名和密码才能访问数据资源。这就需要我们输入用户名和对应的密码。 案例:请求URL如下,授权账号： 用户名: postman 密码password 授权协议为: Basic auth https://postman-echo.com/basic-auth 如果不输入用户名密码,直接使用GET请求,则会返回提示: Unauthorized 输入用户名密码,选择 Basic auth授权类型,则返回如下结果： { \"authenticated\": true } Digest Auth Digestauth是一个简单的认证机制,最初是为HTTP协议开发的,因此也常叫做HTTP摘要。其身份验证机制非常简单,它采用哈希加密方法,以避免用明文传输用户的口令。 摘要认证就是要核实參与通信的两方都知道双方共享的一个口令。 当 server想要查证用户的身份,它产生一个摘要盘问( digest challenge),并发送给用户。典型的摘要盘问例如以下： Digest realme\"iptel org\",qops=\"auth, auth-int \", nonces =\"dcd98b7102dd2fee8b11d0f600bfbece93\", opaque\"\", algorithm=MD5 这里包含了一组参数,也要发送给用户.用户使用这些參数,来产生正确的摘要回答,并发送给 server.摘要盘问中的各个參数,其意义例如以下: realm(领域):领域參数是强制的,在全部的盘问中都必须有.它是目的是鉴别SP消息中的机密。在SIP实际应用中,它通常设置为SP代理 server所负责的域名。 nonce(现时):这是由 server规定的数据字符串,在 server每次产生一个摘要盘问时,这个參数都是不一样的(与前面所产生的不会雷同)。 \"现时\"一般是由一些数据通过md5杂凑运算构造的.这种数据通常包含时间标识和 server的机密短语.这确保每一个\"现时\"都有一个有限的 生命期(也就是过了一些时间后会失效,并且以后再也不会使用),并且是独一无二的(即不论什么其他的 server都不能产生一个同样的\"现时\")。 algorithm(算法):这是用来计算的算法.当前仅仅支持MD5算法。 qop(保护的质量)：这个參数规定 server支持哪种保护方案。 client能够从列表中选择一个。值auth表示仅仅进行身份查验,auth-int表示 进行查验外,另一些完整性保护.须要看更具体的描写叙述,请參阅RFC2617。 案例 请求URL如下 https://postman-echo.com/digest-auth 摘牌配置信息如下:用户名密码和上面 basic auth一样 Digest username=\"postman\", realm=\"Users\",nonce=\"nilLiL0037PRRhofwdCLmw FsnEtHllew\", uri=\"/digest-auth\", response= \"254679099562cf07df9b6f5d8d15db44\",opaque=\" \" 执行请求结果如下: { \"authenticated\": true } Hawk Auth Hawk Auth是一个HTP认证方案,使用MAC( Message Authentication Code,消息认证码算法)算法,它提供了对请求进行部分加密验证的认证HTTP请求的方法。 hawk方案要求提供一个共享对称密匙在服务器与客户端之间,通常这个共享的凭证在初始TLS(安全传输层协议)保护阶段建立的,或者是从客户端和服务器都 可用的其他一些共享机密信息中获得的。 案例 请求URL如下: https://postman-echo.com/auth/hawk 密钥信息如下: Hawk Auth ID: dh37fg 492je Hawk Auth Key: werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn Algorithm; sha256 执行结果: { \"message\":\"Hawk Authentication Successful\" } 如果将key改为其他任意的字符则返回如下结果: { \"statuscode\":401, \"error\":\"Unauthorized\", \"message\":\"Bad mac\", \"attributes\": { “error\":\"Bad mac” } } OAuth 1.0 OAuth(开放授权)是—个开放标准,允许用户让第三方应用访问该用户在某一网站上存储的私密的资源(如照片,视频,联系人列表), 而无需将用户名和密码提供给第三方应。 用扩展资料 OAuth那些事儿 [OAuth的改变]（https://blog.huoding.com/2011/11/08/126） 案例 请求URL如下:请求方式为GET, Add authorization data to设置为: Request Headers https://postman-echo.com/oauth1 参数配置为 Consumer Key: RKCGzna7bv9YD57c Consumer Secret: D+EdQ-gs$-%@2Nu7 发送请求结果如下: { \"status\":\"pass\", \"message\":\"0Auth-1ea signature verification was successful\" } 如果 Consumer Secret错误则返回如下结果 { \"status\":\"fail\", \"message\":\"HMAC-SHAl verification failed\", baseuri\":https://postman-echo.com/oauth1, \" normalized param string\": \" oauth_consumer _ey=51Zxw&oauth _nonce=pxSgzUivsB1&oauth _signature method=HMAC-SHA1&oauth timestamp=153129 9384&oauth version=1.0\", “base string”： “ Get&httPs%3a%2f%2fpostman- echo.com%2foauth1&oauthconsumerkey%3d51zxw%26oautHnonce%3dpxsgzuivsb1%26oau th _signature methodx3DHMAC-SHA1%26oauth timestamp%3D1531299384%26oauth version%3D1.0, \"signing key\":\"DX2BEdQ-g5%24-%25%402Nu7&\" } 扩展资料:各个授权协议文档 Cookie设置 cookie是存储在浏览器中的小片段信息,每次请求后都将其发送回服务器,以便在请求之间存储有用的信息。比如很多网站登录界面都有保留账号密码,以便下次登录。 由于HTTP是一种无状态的协议,服务器单从网络连接上无从知道客户身份。怎么办呢?就给客户端们颁发一个通行证吧,每人一个,无论谁访问都必须携带自己通行证。 这样服务器就能从通行证上确认客户身份了.这就是 Cookie的工作原理。 Cookie是由服务端生成,存储在响应头中,返回给客户端,客户端会将 cookie存储下来,在客户端发送请求时, user- agent会自动获取本地存储的 cookie,将 cookie信息 存储在请求头中,并发送给服务端. postman也可以设置、获取、删除 Cookie。 Set Cookies 在Send按钮下方点击 Cookies文字菜单,弹出如下界面,然后可以设置 Cookie。 请求URL如下:请求方式为GET添加 Cookie值为 username:51zXw http://www.baidu.com 打开 Console找到 Request Header可以看到自定义设置的 Cookie内容。 Get Cookies Cookie获取比较简单,直接获取 Response Headers里面的set- cookie值即可,或者在主界面下方 Cookie菜单栏里面也可以查看。 Delete Cookies 点击 Cookies文字菜单，然后可以根据需求去清除对应的 Cookie。 变量 问题思考 在开发不同阶段可能存在不同的环境比如测试环境和生产环境。 测试环境AP|如下： https://dev.postman.com/get https://dev.postman.com/get https://dev.postman.com/put 生产环境AP如下: https://postman-echo.com/get https://postman-echo.com/post https://postman-echo.com/put 在这么情况下,按照常规思路要么你需要维护两套环境的AP,要么毎次都手动一个个去修改URL,不管哪种选择都比较麻烦且低效, 那么有没有比较的好的方法来解决这个问题呢? Postman变量类型 通过比较我们可以发现,以上两组AP主要是除了host不同之外其他都一样,其实把Host用变量替换,这样就可以灵活切换环境。 Postman提供了变量设置,有4种变量类型。 本地变量( Localvariable) 全局变量( Global Variable 环境变量( Environment variable) 数据变量( Data Variable) 环境变量 环境变量指在不同环境,同一个变量值随着环境不同而变化,比如我们上面举例场景就可以使用环境变量,当在测试环境时, host值为:dev.postman.com,当切換到生产环境时,host值变为:postman-echo.com 环境变量设置：在 postman界面点击右上角眼睛图标,即可开始设置环境变量和全局变量.环境变量设置过程如下图所示: 我们可以设置两种环境deν和 release. deν是开发测试环境; release是正式的生产环境.host环境变量,根据不同的环境值 不一样。 详细过程见视频演示。 本地变量 本地变量主要是针对单个URL请求设置的变量,作用域只是局限在请求范围内。如请求URL如下, 设置两个本地变量( user, passwd)作为参数.请求方式为POST https://postman-echo.com/post 从上图中我们可以看到变量设置的格式为 变量设置好之后需要赋值,在pre- request- Script里面编写如下代码: pm.variables.set( \"user\",\"51ZXW\"); pm.variables.set(\"passwd\",\"66666\"); 点击send执行之后的返回值如下,可以看到我们定义的变量已经发送。 全局变量 全局变量是指在所有的环境里面,变量值都是一样的,全局变量的作用域是所有请求。 全局变量设置有两种方式: 点击界面里设置 在脚本里设置 界面设置 点击眼睛图标后,在 Global选项菜单点击εdit菜单即可设置全局变量,如下图所示.全局变量的引用格式和环境变量一样。 注意:当环境变量和全局变量名称一样时,切换到某个环境时,环境变量会覆盖全局变量。 脚本设置 使用如下脚本可以设置全局变量: variable key表示变量名称, variable_ value表示变量值。 pm.globals.set(\"variable_key\",\"variable_value\"); 实践案例 在实际接口测试过程中,接口经常会有关联。比如需要取上一个接口的某个返回值,然后作为参数传递到下一个接口作为参数。 假设我们要获取A接口返回的 userid值作为B接口的请求参数。 A接口请求URL如下： https://postman-echo.com/post 请求方式为Post 请求参数: userid(这里自己定义,接口会返回对应的id值) 返回值 根据返回值我们需要从返回值中提取 userid值。在τest标签栏下编写如下脚本获取υserid值 B接口请求URL如下:请求方式为GET postman-echo.com/get?userid= 先执行A接口的,然后在执行B接口,此时B接口通过全局变量 userid可以获得A接口的返回值。 数据变量 数据变量是通过导入外部数据文件(json文件或者csv文件),来获取变量数据。 我们可以创建一个如下内容的json文件: data. json 稍后我们会结合运行 Collection来讲解如何导入该数据文件。 断言 简介 一般来说执行完测试,我们需要对测试结果来进行校验,判断结果是是否符合我们的预期,也就是断言。 在接口测试中一般会根据响应状态码或者响应返回的数据来进行断言。 Postman提供一个测试沙箱( Postman Sand box)测试沙箱是一个 JavaScript执行环境,可以通过 JS脚本来编写pre- request Script和 test Script. pre-request Script(预置脚本)可以用来修改一些默认参数在请求发送之前执行.有点类似于 unittest里面的 setUp()方法。 test Script(测试脚本)当接收到响应之后,再执行测试脚本。 案例 接口请求URL如下:请求方式为POST postman-echo.com/post 断言规则 响应状态码:200 响应内容:返回的user参数值与定义的一致 响应时间:小于0.5s 测试脚本 在pre-request script定义变量user pm.variables.set(\"user\",'zxw'); 在Test栏下面编写如下脚本 断言结果 扩展资料: Postman测试脚本官方文档 运行 Collection 批量执行 当我们想批量测试某个集合里面的各个API时,可以使用 Collection Runner来批量运行AP,同时可以进行环境 变量、迭代执行次数、延迟时间等设置。 执行结果 数据驱动 应用背景 有时我们针对一个接口需要测试很多不同的参数,如果每次一个个的去修改参数值来进行测试这样效率肯定会比较低下。 因此我们需要每次迭代执行传入不同的参数进行测试,那么需要导入外部数据文件进行参数化,也就是所谓的数据驱动。 数据导入 如下图所示,data选择之前我们创建的json数据文件: data.json,文件类型选择 application/json json数据内容如下。 请求之前延迟时间最好设置为1000~3000,避免过于频繁请求被禁。 点击 Preview按钮可以预览导入的数据。 执行结果 构建工作流 问题思考 在使用\" Collection runner\"的时候,集合中的请求执行顺序就是请求在 Collection中的显示排列顺序。但是,有的时候我们不希望请求按照这样的方 式去执行,可能是执行完第一个请求,再去执行第五个请求,然后再去执行第二个请求这样的方式;那么在\" Collection Runner\"中如何去构建不同的执 行顺序呢? 设置方法 最直接的方法就是直接在集合里面拖动调整顺序,但是毎次去拖动也比较麻烦,特别是当请求比较多的时候.这时候最高效的方法就是通过脚本设置。 首先下载官方提供的案例文件:collection.json导入到 postman,运行Collection结果如下图所: 接下来要调整执行顺序为: Request1-> Request3-> Request.2-> Request4 首先在第一个请求 Request1中Test添加如下代码:表示下一个请求为执行请求名称为 Request3的请求 postman.setNextRequest('Request 3') 然后在 Request3的请求中Test添加如下代码:表示下一个请求为执行请求名称为 Request2的请求 postman.setNextRequest('Request 3') 最后在 Request2的请求中Test添加如下代码:表示下一个请求为执行请求名称为 Request4的请求。 postman.setNextRequest('Request 3') 注意:第一个执行请求的排序一定要在第一个 执行结果 相关资料: collection runs官方文档 命令执行 问题思考 在前面我们都是在 postman图形界面工具里面进行测试,但是有时候我们需要把测试脚本集成到CI平台,或者在非图形界面 的系统环境下测试,那么该如何处理呢? Newman简介 Newman是一款基于 Node. js:开发的可以运行 Postman的工具,使用 Newman,可以直接从命令行运行和测试Postman集合。 Newman应用 环境准备 Node.js cnpm或npm 以上安装可以参考: Appium环境搭建 配置好环境后,执行如下命令安装 newman cnpm install newman --global 输入如下面命令检测安装是否成功 C: \\Users\\Shuqing>newman -v 3.10.8 执行测试 首先将 postman的集合导出,如下图所示: 在桌面新建文件夹 pmtest将导出的 postman文件和相关数据文件放入。 打开cmd进入到 pmtest目录,输入如下命令： newman run Postman_API. postman_collection.json -d data.json -r html 命令说明 run代表要执行的 postman脚本,即为导出的集合。 -d表示要执行的数据,也就是之前导入 postman的数据 -r生成的测试报告类型这里生成html格式报告 更多命令用法请输入 newman-h即可查看。 报告查看 在测试文件夹 pmtest里面可以看到生成的一个 newman文件夹,打开就可以看到生成的测试报。 Html报告样式:newman-run-report newman不仅支持生成html报告,还支持其他报告类型: JSON reporter JUNIT/XML reporter Client repo Html report 集成 Jenkins Jenkins简介 Jenkins是—个开源软件项目,是基于Java开发的_种[持续集成]工具,用于监控持续重复的工作,旨在提供一个开放易用的软件平台, 使软件的持续集成变成可能。 下载与安装 下载地址:https://jenkins.io/download/ 下载后安装到指定的路径即可默认启动页面为 localhots:8080如果8080端口被占用无法打开,可以进入到 jenkins安装目录,找到 jenkins.xm配置文件打开,修改如下代码的端口号即可。 集成步骤 集成到 jenkins的思路其实很简单,就把之前我们执行测试的cmd命令放到 jenkins里面去执行。集成步骤也很简。 首先新建一个项目: postman_ api_test 然后在构建栏目下拉菜单选择 Execute windows batch command Tips:我的 jenkins:安装在D盘因此需要使用命令c:切换到 postman脚本所在盘符。 最后执行结果如下： 其他设置如设置定时执行,可以参考 Apium教程中的:6-14框架综合实践(13) ——jenkins自动化测试平台搭建 导出不同语言脚本 问题思考 虽然 Postman功能比较强大,但是毕竟是一款商业工具,多少会有一些限制.比如只支持js脚本运行,如果我们想用自己熟悉的 编程语言(如: Python java等)来做接口自动化测试该如何处理? 操作步骤 Postman支持导出不同语言版本的脚本,当一个接口调试好之后,点击右侧的code字样即弹出如下界面可以选择语言.最后选择 你需要语言版本即可生成对应的代码。 生成的代码片段可以点击 Copy to Clipboard复制。 参考资料 https://docs.postman-echo.com/?version=latest#1eb1cf9d-2be7-4060-f554-73cd13940174 https://www.jellythink.com/archives/169 https://blog.csdn.net/wangyuquanliuli/article/details/24850761 https://www.cnblogs.com/happy-today/p/7928822.html http://www.mamicode.com/info-detail-1693734.html https://blog.csdn.net/qq_14908027/article/details/77923792 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第二章/Jmeter接口测试.html":{"url":"第二章/Jmeter接口测试.html","title":"第2节：Jmeter接口测试","keywords":"","body":"第2节：Jmeter接口测试 Jmeter概述 Jmeter简介 Apache JMeter是 Apache组织的开放源代码项目,是一个纯Java桌面应用,用于压力测试和性能测试.它最初被设计用于Web应用测试但后来扩展到其它测试领域 Jmeter功能 能够对HTP和FTP服务器进行压力和性能测试,也可以对任何数据库进行同样的测试(通过JDBC)。 完全的可移植性和100%纯java。 完全 Swing(ava设计的GU工具包)和轻量组件支持。 完全多线程框架允许通过多个线程并发取样和通过单独的线程组对不同的功能同时取样。 精心的GU设计允许快速操作和更精确的计时。 缓存和离线分析/回放测试结果。 Jmeter接口测试 Jmeter接口测试的简单操作包括做http脚本编辑(发get/post请求cookie设置header设置、权限认证)参数化、断言、关联和数据驱动等等。 Jmeter安装启动 下载安装 Jmeter下载地址 Jmeter官方文档 Jmeter基础教程 说明 一般开放原代码软件都会有两个版本发布: Source和 Binary Source是源代码版,你需要自己编译成可执行软件。 Binary是可执行版,直接可以拿来用的,他已经给你编译好的版本。 下载后,解压文件到任意目录,避免在有空格的路径安装 JMeter。 环境依赖:java环境,需要自行安裝配置好JK环境变量參考帖子。 启动软件 进入到 Imeter的bin目录,双击运行 Apache ]Meter,jar即可启动软件,如下界面 Jmeter接口测试实战 Jmeter脚本编写一般分五个步骤: 添加线程组 添加http请求 在http请求中写入接入ur、路径、请求方式和参数 添加查看结果树 调用接口、查看返回值 测试API http://httpbin.org/ 发送Get请求 请求URL如下： http://httpbin.org/get 在Jmeter i配置如下图所示: 在查看结果树选择 Json Path Tester如下图所示可以看到返回结果: 发送POST请求 请求URL如下： http://httpbin.org/post Jemeter配置如下图所示： 响应结果： HTTP请求默认值 通过上面两个请求我们发现,Web服务器中的协议和服务器名称或IP这两个值都是一样,每次重复输入其实比较麻烦,因此我们可以使用HTTP请求默认值来管理这些公共的配置数据。 添加步骤:线程组——添加——配置元件—HTTP请求默认值然后进行如下配置,并把该元件放置到请求前面。 经过请求默认值的配置后,后续我们増加新的请求,如果这两项值是一样的话,那么则无需再重复填入该值。 断言设置 Jmeter可以针对毎一个请求响应进行断言.设置步骤选中一个请求,如http-get然后右键选择:添加—断言一响应断言。 各个匹配模式含义如下： 包括:响应内容包括需要匹配的内容即代表响应成功,支持正则表达式 匹配:响应内容要完全匹配需要匹配的内容即代表响应成功,大小写不敏感,支持正则表达式. Equals:响应内容要完全等于需要匹配的内容才代表成功,大小写敏感,需要匹配的内容是字符串正则表 Substring:返回结果包含指定结果的字串,但是 subString不支持正则字符串 否:不进行匹配 如下图所示匹配返回的字符串是否包含http://httpbin.org/get 如果断言成功,则查看结果树为绿色标志,如果断言失败则为红色显示,如下图所示： 参数设置 Jmeter支持通过 Query String Parameters或者 Request body请求体来传递参数。 Query String Parameters 如果希望在请求URL中添加参数,则可以在Http请求界面的 Parameters选项里面添加参数。该参数会通过 Query String Parameters方式传递给服务器,也就是在URL中传递参数.如下图如所示设置参数： Request body 在Post请求中参数一般在body中传递, Jmeter也支持在body中传递参数.如传递Json格式的参数,在Body pata编辑框输入如下参数： [username\": 51ZxW\"} 另外还需要指定参数的格式,因此需要添加HTTP信息头管理器 添加步骤：选定请求——添加——配置元件——HTTP信息头管理器,然后在管理器里面添加参数类型 Content-Type: application/json如下图所示： 变量 在请求过程中,有时我们需要在请求中设置一些变量来测试不同的场景。 Jmeter支持以下类型变量： 用户自定义变量 函数生成变量 Bean Shell!变量 数据文件变量 用户自定义变量 设置步骤：选中请求——添加——前置处理器——用户参数设置变量名称为υser,值为51zxw 在请求时引用变量如下所示:变量引用格式为:${user} 函数生成变量 Jmeter有许多内置的函数,可以生成随机数.创建步骤点击菜单栏选项—函数助手对话框——下拉选择_Random()函数 函数配置如下: Bean Shel变量 什么是 Bean Shell!? Bean She是一种完全符合Java语法规范的脚本语言,并且又拥有自己的一些语法和方法; Bean She是一种松散类型的脚本语言这点和JS类似); Bean She是用Jaνa写成的一个小型的、兔费的、嵌入式的Java源代码解释器,具有对象脚本语言特性非常精简。 Bean Shell执行标准Java语句和表达式另外包括一些脚本命令和语法。 官网http://www.beanshell.org Jmeter有哪些 Bean Shel 定时器Bean Shell Timer 前置处理器: Bean Shell PreProcessor 采样器: Bean Shell Sampler 后置处理器: Bean Shell PostProcessor 断言:Bean Shel 断言监听器: Bean shell listener Bean Shell 常用内置变量 JMeter 在它的 BeanShell 中内置了变量，用户可以通过这些变量与 JMeter 进行交互，其中主要的变量及其使用 方法如下: vars - (JMeterVariables)：操作jmeter变量，这个变量实际引用了JMeter线程中的局部变量容器（本质上是Map）， 它是测试用例与 BeanShell 交互的桥梁，常用方法： //定义 jmeter 变量 vars.put(String key，String value); //从 jmeter 中获取变量 vars.get(String key); log：写入信息到 jmeber.log 文件，使用方法： log.info(“hello 51zxw!”); BeanShell 实践案例 1.创建请求名为 beanshell_test 的 Http 请求，请求地址为：http://httpbin.org/get 同时设置传递的参数为 beanshell_user 2.创建 BeanShell PreProcessor 变量设置如下所示： 3.最后运行结果可以看到，设置的变量已经生效 CSV 数据文件变量 CSV 数据文件变量是指从外部 csv 文件读取数据出来作为变量。 设置步骤: 选择请求——添加——配置元件——CSV 数据文件设置 创建 csv 文件（最好不用用记事本创建，推荐用 Nodepad++）文件编码为 UTF-8 文件内容如下： user_data.csv 51zxw,8888 CSV 数据文件设置如下： 在 Post 请求中引用变量数据如下： 运行之后在查看结果树中请求选项栏可以看到获取的变量数据。 POST http://httpbin.org/post POST data: user=51zxw&password=8888 [no cookies] Request Headers: Connection: keep-alive Content-Type : application/json Content-Type: application/x-www-form-urlencoded Content-Length: 24 Host: httpbin.org User-Agent: Apache-HttpClient/4.5.5 (Java/1.8.0_05) CSV 参数化 针对之前的 POST 接口进行如下参数遍历测试： 接口如下： http://httpbin.org/post 发送参数：user_data.csv 51zxw,8888 51zxw1,6666 51zxw2,4444 51zxw3,5555 在之前的 csv 数据文件设置需要需改配置如下：表示把所有数据读取一遍，且不重复。 接口请求名称格式更改为：http-post-${user} 方便我们后续查看数据遍历情况。 最后修改线程组的线程数量，因为数据中有 4 组数据，所以设置为 4. 运行查看结果如下: 正则匹配 问题思考 接口测试过程中经常需要接口之间关联调用，比如获取上一个接口的返回值，作为另一个接口的请求参数，那么该 如何从处理呢？这里需要使用 Jmeter 的正则表达式提取器，通过对响应的数据来提取指定的数据。 操作案例 从请求 http-get 响应数据中匹配随机数 num 的值，然后创建请求 get-num 来引用 num 的作为请求参数。 设置步骤： 选中请求——添加——后置处理器——正则表达式提取器 根据 http-get 的响应，提取返回值中的 num 配置如下： 正则表达式配置表 引用名称：请求要引用的变量名称，如填写 result_num，则可用${result_num}引用它。 正则表达式：匹配需要的内容。 模板：用$num$引用起来，如果在正则表达式中有多个匹配数据，num 表示匹配到的第几个值给变量。如： $1$表示匹配到的第 1 个值存储在变量中。 匹配数字：0 代表随机取值，1 代表全部取值， 缺省值：如果参数没有取得到值，那默认给一个值让它取。案例中正则表达式说明 ()括起来的部分就是要提取的。 .匹配任何字符串。 +一次或多次。 ?在找到第一个匹配项后停止。 相关资料：正则表达式教程 新建一个请求 get-num，在新的请求中将 http-get 返回的数据作为参数传递，如下图所示： 用例数据分离 之前我们的用例数据都是配置在 Jmeter Http 请求中，每次需要增加，修改用例都需要打开 jmeter 重新编辑，当 用例越来越多的时候，用例维护起来就越来越麻烦，有没有好的方法来解决这种情况呢？ 其实我们可以将用例的数据存放在 csv 文件中，然后通过 csv 文件配置来读取用例中的数据，执行测试。用例数据 如下图所示： 用例设计 这里以 httpbin 接口为例，创建用例文件：jmeter-testcase.csv 用例名称变量含义： ${caseSeq}:用例编号 ${apiType}:api 类型 ${apiSeq} ：api 版本号 ${apiName}：api 名称 ${priority}:优先级 ${url}:api 路径 ${methods}:请求方法 ${parameter}: 请求参数 ${expectValue}:期望值，用于断言 Jmeter 设置步骤： 1.新建一个线程组，命名为：数据驱动 2.创建一个 http 请求默认值，设置如下： 3.添加一个循环控制器 步骤为：线程组——添加——逻辑控制器——循环控制器。 循环控制器的作用可以控制整 个用例循环执行的次数。默认值是 1 根据用例数量可以修改为 4 4.在循环控制器节点下创建 CSV 文件设置，具体配置内容如下: 5.创建一个 if 控制器，步骤为：线程组——添加——逻辑控制器——if 控制器 if 控制器的作用为根据不同条件执行不同的用例，例如这里根据不同的接口请求类型，分别创建了 GET 和 POST 两个 控制器。 GET 设置的条件语句如下： 条件语句为：\"${methods}\"==\"GET\"其中 ${methods}表示引用 csv 中的 methods 中的值。 参数： Interpret Condition as Variable Expression?：如果这个选项被选中，将不会使用 js 解析;条件表达式的 值必须是 true(忽略大小写)，这里我们取消勾选状态。 Evaluate for all children：如果选中这一项，在每个子结点执行前都会计算表达式 POST 条件语句设置为：\"${methods}\"==\"POST\"} 6.创建 GET 请求类型的用例如下 用例名称格式：${caseSeq}_ ${apiSeq}_${apiName} 断言设置如下：${expectValue}引用 csv 中对应的值。 最后添加查看结果树，然后运行可以看到如下运行结果： 7.POST 用例设置和 GET 类似，不过参数请求不一样，是在 body 中。另外请求方式为：POST 运行结果如下: 8.最后在线程组添加一个查看结果树，执行可以查看全部用例执行情况。 小结 通过这样的数据驱动，当面对大量用例时在 jmeter 设置就非常方便，后续的用例维护也非常高效，因为不用在 jmeter 一个个去单独修改用例了。 Cookie 设置 HTTP Cookie 管理器 如果你有一个 HTTP 请求，其返回结果里包含一个 cookie，那么 使用 JmeterCookie 管理器会自动将该 cookie 保存起来，而且以后所有对该网站的请求都使用同一个 cookie。每个 JMeter 线程都有自己独立的\"cookie 保存 区域\"。 案例实践 请求 URL 如下： http://httpbin.org/cookies/set 以上请求会返回 cookie，Cookie 内容可以通过自定义参数设置。这里我们设置 Cookie 内容如下： 添加 Cookie 管理器：选中线程组——添加——配置元件——HTTP Cookie 管理器 运行之后我们可以在查看结果树看到 Cookie： 我们继续发送新的请求也会自动包含该 Cookie 请求 URL 为：http://httpbin.org/cookies 运行之后结果如下 授权设置 应用背景 在介绍 Postman 的过程中，我们学习了使用 Postman 对各种授权协议的接口进行测试，在 Jmeter 中同样也支持 对需要授权的接口进行测试。关于各个授权协议的内容请参考 Posman 内容中的介绍。 Basic Auth 请求接口为： http://httpbin.org/basic-auth/{username}/{passwd} 设置用户名为：51zxw 密码：8888 新建 http 请求名称为：basic-auth 设置如下： 然后添加 HTTP 授权管理器：选中请求——添加——配置元件——HTTP 授权管理器 配置如下： 执行结果如下： 请求内容： GET http://httpbin.org/basic-auth/51zxw/8888 GET data: Cookie Data: user=51zxw Request Headers: Connection: keep-alive Host: httpbin.org User-Agent: Apache-HttpClient/4.5.5 (Java/1.8.0_05) Authorization: Basic NTF6eHc6ODg4OA== 可以请求内容中带有授权信息 Authorization: Basic NTF6eHc6ODg4OA== , 而 NTF6eHc6ODg4OA==这个数值就 是用 用户名：密码经过 Base64 编码后计算出来的。 Digest Auth 请求 URL 为： http://httpbin.org/digest-auth/{qop}/{username}/{password} {qop} 这个參数规定 server 支持哪种保护方案。client 能够从列表中(auth,auth-int)选择一个。 auth 表示仅仅进行身份查验， auth-int 表示进行查验外，另一些完整性保护。 新建 http 请求：digest-auth 设置用户名为 zxw2018 密码为：8888 配置如下： 然后添加 HTTP 授权管理器 配置如下： 执行之后响应结果： {\"authenticated\":true,\"user\":\"zxw2018\"} 请求内容： GET http://httpbin.org/digest-auth/auth/zxw2018/8888 GET data: [no cookies] Request Headers: Connection: keep-alive Host: httpbin.org User-Agent: Apache-HttpClient/4.5.5 (Java/1.8.0_05) Authorization: Digest username=\"zxw2018\", realm=\"me@kennethreitz.com\", nonce=\"251670f7b11c5026ab699a02906fffb8\", uri=\"/digest-auth/auth/zxw2018/8888\", response=\"23a0c70610b80d1f2daaf9cad6cc63f1\", qop=auth, nc=00000001, cnonce=\"fedb59626b738c01\", algorithm=MD5, opaque=\"0bfc81209d832d1858f8bb4c4e4d01b6\" 通过上面的请求内容 Authorization 值和之前的 Basic Auth 有不一样。 测试报告 批量执行完接口测试之后，我们需要查看测试报告，在之前单个接口调试我们是通过查看结果树查看结果，但是当大 批量执行接口测试之后依旧这样查看那么肯定会很低效 那么该如何设置呢？ 聚合报告 聚合报告是一个比较精简的报告元件，可以查看每个接口的性能情况与执行结果。 设置步骤：选中线程组——添 加——监听器——聚合报告。 报告各个参数含义如下： Samples -- 本次场景中一共完成了多少个请求 Average -- 平均响应时间(单位：ms) Median -- 响应时间的中值(单位：ms) 90% Line -- 所有请求中 90%的响应时间。 Min -- 最小响应时间(单位：ms) Max -- 最大响应时间(单位：ms) Error -- 出错率 Troughput -- 吞吐量 Received--响应数据大小 KB/sec -- 以流量做衡量的吞吐量 HTML 报告 有时候我们需要将测试报告以 HTML 附件形式发送给各个项目成员，那么需要生成 HTML 报告。 JMeter3.0 以后 引入了 Dashboard Report，用于生成 HTML 页面格式图形化报告的扩展模块。 生成步骤： 打开 cmd 进入 jmeter 目录 bin 目录 执行命令： jmeter -n -t httpbin_test.jmx -l httpbin.jtl -e -o C:\\Users\\Shuqing\\Desktop\\report 命令的参数： -n ：以非 GUI 形式运行 Jmeter -t ：jmeter 脚本路径 -l ：result.jtl 运行结果保存路径（.jtl）此文件必须不存在。 -e ：在脚本运行结束后生成 html 报告 -o ：用于存放 html 报告的目录，不加该参数默认生成到 bin\\report-output 生成的测试报告样式如下： 参考资料 https://baike.baidu.com/item/Jmeter/3104456?fr=aladdin https://blog.csdn.net/zhizunyu2009/article/details/79011413 https://blog.csdn.net/gld824125233/article/details/52842914 https://blog.csdn.net/defonds/article/details/53517247 https://stackoverflow.com/questions/12560494/jmeter-basic-authentication https://blog.csdn.net/wuyou10206/article/details/77539791 https://blog.csdn.net/huangjuyan/article/details/52993758 https://www.houxue.com/news-1279775/ https://blog.csdn.net/qq_35451939/article/details/79716010 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第二章/Jmeter+Ant+Jenkins接口自动化测试平台.html":{"url":"第二章/Jmeter+Ant+Jenkins接口自动化测试平台.html","title":"第3节：Jmeter+Ant+Jenkins接口自动化测试平台","keywords":"","body":"第3节：Jmeter+Ant+Jenkins接口自动化测试平台 平台简介 一个完整的接口自动化测试平台需要支持接口的自动执行，自动生成测试报告，以及持续集成。Jmeter 支持接口的 测试，Ant 支持自动构建，而 Jenkins 支持持续集成，所以三者组合在一起可以构成一个功能完善的接口自动化测 试平台。 环境准备 环境依赖 JDK 环境配置 Jmeter 安装 Ant 安装环境变量配置 Jenkins 安装 ​ Ant 简介 Apache Ant,是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于 Java 环境中的软 件开发。 下载安装 下载地址：https://ant.apache.org/bindownload.cgi 下载之后解压到任意文件路径，我这里是放到 C 盘根目录。 环境变量配置 ANT_HOME C:\\apache-ant-1.10.5 Path : %ANT_HOME%\\bin ClassPath %ANT_HOME%\\lib 配置检测 输入如下命令即可检查是否安装成功 C:\\Users\\Shuqing>ant -version Apache Ant(TM) version 1.10.5 compiled on July 10 2018 注意：如果提示‘ant 不是内部命令也不是外部命令’ 说明环境变量可能配置错误。 Jenkins 简介 Jenkins 是一个开源软件项目，是基于 Java 开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 下载与安装 下载地址：https://jenkins.io/download/ 下载后安装到指定的路径即可，默认启动页面为 localhots:8080,如果 8080 端口被占用无法打开，可以进入到jenkins 安装目录，找到 jenkins.xml 配置文件打开，修改如下代码的端口号即可。 -Xrs -Xmx256m -Dhudson.lifecycle=hudson.lifecycle.WindowsServiceLifecycle -jar \"%BASE%\\jenkins.war\" --httpPort=8080 --webroot=\"%BASE%\\war\" 平台搭建 依赖文件配置 首先在 Jmeter 目录下面新建一个文件夹 loadTest (文件夹名称不要使用下划线，空格字符),并将 Jemter 测 试脚本放置到该文件夹中。 将 Jmeter extras 文件中的 ant-jmeter-1.1.1.jar 放到 Ant 中的 lib 文件夹中 将 Jmeter extras 文件中的 jmeter-results-detail-report_21.xsl ,build.xml、collapse.png、expand.png 放 到 ant 目录中的 bin 目录下面。 build.xml 配置 在 Ant 的 bin 目录中打开 build.xml 文件找到以下内容 参数说明 testpath 测试计划，这里用于存放测试脚本、测试生成的文件、测试报告 jmeter.home Jmeter 目录路径 report.title 测试报告的标题 test jmeter 测试脚本的名称（无需后缀.jmx） 这里根据自己的环境修改为 Ant 构建 执行如下命令进行构建 ant -buildfile C:\\apache-ant-1.10.5\\bin\\build.xml 结果如下： 进入到 loadTest 文件夹可以看到生成如下文件： 打开 html 测试报告 httpbin_test.html 报告内容如下： 报告优化 Jmeter 默认生成报告不是很详细，因此我们需要进行优化。这里我们使用新的报告模板： jmeter-results-detail-report_30.xsl 默认的报告模板是 jmeter-results-detail-report_21 打开 build.xml 将 21 改为 30 补充删除 .jtl 的代码，如果不删除每次迭代的记录都会显示在报告里面，显得很冗余。 funcMode = ${funcMode} 进入 Jmeter 的 bin 目录，找到 jmeter.properties 文件打开。然后将以下代码取消注释状态，并改为 true jmeter.save.saveservice.data_type=true jmeter.save.saveservice.label=true jmeter.save.saveservice.response_code=true # response_data is not currently supported for CSV output jmeter.save.saveservice.response_data=true # Save ResponseData for failed samples jmeter.save.saveservice.response_data.on_error=true jmeter.save.saveservice.response_message=true jmeter.save.saveservice.successful=true jmeter.save.saveservice.thread_name=true jmeter.save.saveservice.time=true jmeter.save.saveservice.subresults=true jmeter.save.saveservice.assertions=true jmeter.save.saveservice.latency=true # Only available with HttpClient4 jmeter.save.saveservice.connect_time=true jmeter.save.saveservice.samplerData=true jmeter.save.saveservice.responseHeaders=true jmeter.save.saveservice.requestHeaders=true jmeter.save.saveservice.encoding=true jmeter.save.saveservice.bytes=true # Only available with HttpClient4 jmeter.save.saveservice.sent_bytes=true jmeter.save.saveservice.url=true jmeter.save.saveservice.filename=true jmeter.save.saveservice.hostname=true jmeter.save.saveservice.thread_counts=true jmeter.save.saveservice.sample_count=true jmeter.save.saveservice.idle_time=true 最后执行即可生成最新的报告：样式如下，可以清晰看到每一个请求发送，响应内容。 注意 如果生成的报告为空，则说明 jmeter 脚本有错误，此时可以打开 jmeter 的 bin 目录中的 jmeter.log 日志文件，查看具体的报错信息。 集成到 Jenkins 在 Jenkins 新建一个任务 httpbin_Api_test 在构建选项中选择 Invoke Ant 然后在 Build File 输入 build.xml 配置文件路径。注意：不要输入到 Targets 里面去 了，需要点击高级选项后才可以显示除 Build File 执行之后可以看到控制台输出和 cmd 的控制台输出是一样的 如果想定制构建则可以在构建触发器中选择 Build periodically 如果想每个工作日下班 18 时执行，则可以如下设置： 扩展资料：Appium jenkins 自动化测试平台搭建 邮件推送 参考 python 邮件发送 参考资料 • https://baike.baidu.com/item/apache ant/1065741 • http://www.cnblogs.com/puresoul/p/5049433.html • https://testerhome.com/topics/2580 • https://blog.csdn.net/yinjing8435/article/details/71159403 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第二章/jmeter基础使用手册.html":{"url":"第二章/jmeter基础使用手册.html","title":"第4节：jmeter基础使用手册","keywords":"","body":"第4节：jmeter基础使用手册 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第三章/":{"url":"第三章/","title":"第三章","keywords":"","body":"第三章 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第三章/Requests库使用.html":{"url":"第三章/Requests库使用.html","title":"第1节：Requests库使用","keywords":"","body":"第1节：Requests库使用 概述 前面我们介绍了接口测试工具：Postman 和 Jmeter。利用接口测试工具上手使用虽然容易，但是还是不够灵活。 例如需要界面上各种配置，有时还需限定的语言脚本来辅助（Postman 限定使用 Js,Jmeter 限定使用 Java） 因此,如果我们直接使用自己熟悉的语言编写代码来进行接口测试将会更加灵活方便，这里我们将使用 Python 来进 行接口测试。 Requests 进行接口测试需要发送 HTTP 请求，Python 最基础的 HTTP 库有 Urllib、Httplib2、Requests、Treq 等，这里 我们推荐使用 Requests 库来进行接口测试。 Requests 基于 urllib，采用 Apache2 Licensed 开源协议的 HTTP 库。它比 urllib 更加方便，可以节约我们 大量的工作，完全满足 HTTP 测试需求。目前很多 Python 爬虫也使用 Requests 库。 官方文档摘要 Requests 口号为：“让 HTTP 服务人类” Requests 中文文档 Requests github 项目主页 Requests 唯一的一个非转基因的 Python HTTP 库，人类可以安全享用。 警告：非专业使用其他 HTTP 库会导致危险的副作用，包括：安全缺陷症、冗余代码症、重新发明轮子症、啃文 档症、抑郁、头疼、甚至死亡。 用户见证 Twitter、Spotify、Microsoft、Amazon、Lyft、BuzzFeed、Reddit、NSA、女王殿下的政府、Amazon、Google、 Twilio、Mozilla、Heroku、PayPal、NPR、Obama for America、Transifex、Native Instruments、Washington Post、Twitter、SoundCloud、Kippt、Readability、以及若干不愿公开身份的联邦政府机构都在内部使用。 功能特性 Keep-Alive & 连接池 国际化域名和 URL 带持久 Cookie 的会话 浏览器式的 SSL 认证 自动内容解码 基本/摘要式的身份认证 优雅的 key/value Cookie 自动解压 Unicode 响应体 HTTP(S) 代理支持 文件分块上传 流下载 连接超时 分块请求 支持 .netrc（用户配置脚本文件） Requests 安装 使用 pip 安装命令如下： pip install requests 安装检测 打开 cmd 窗口，输入 python 然后导入 requests 如果安装成功没有任何提示 import requests 如果提示如下内容则说明安装失败 ImportError: No module named 'requests' 如果没有安装 pip 的参考：Python 安装与配置 Requests 基础应用 发送不同类型 HTTP 请求 requests 库内置了不同的方法来发送不同类型的 http 请求，用法如下所示： request_basic.py import requests base_url='http://httpbin.org' #发送 GET 类型的请求 r=requests.get(base_url+'/get') print(r.status_code) #发送 Post 类型请求 r=requests.post(base_url+'/post') print(r.status_code) #发送 PUT 类型请求 r=requests.put(base_url+'/put') print(r.status_code) #发送 Delete 类型请求 r=requests.delete(base_url+'/delete') print(r.status_code) 执行结果，200 是状态码表示发送请求成功。 200 200 200 200 参数传递 传递 URL 参数 一般在 GET 请求中我们使用查询字符串(query string)来进行参数传递，在 requests 库中使用方法如下： request_basic.py import requests base_url='http://httpbin.org' param_data={'user':'zxw','password':'666'} r=requests.get(base_url+'/get',params=param_data) print(r.url) print(r.status_code) 执行结果 C:\\Python35\\python.exe D:/api_test/requests_api_test/params.py http://httpbin.org/get?user=zxw&password=666 200 Process finished with exit code 0 传递 body 参数 在 Post 请求中，一般参数都在请求体（Request body）中传递，在 Requests 中用法如下： form_data = {'user': 'zxw', 'passwd': '8888'} r=requests.post(base_url+'/post',data=form_data) print(r.text) 执行结果： { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"passwd\": \"8888\", \"user\": \"zxw\" }, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Connection\": \"close\", \"Content-Length\": \"20\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"User-Agent\": \"python-requests/2.18.4\" }, \"json\": null, \"origin\": \"110.52.4.225\", \"url\": \"http://httpbin.org/post\" } 请求头定制 如果你想为请求添加 HTTP 头部，只要简单地传递一个 dict 给 headers 参数就可以了。 用法如下： form_data = {'user': 'zxw', 'passwd': '8888'} header={'user-agent':'Mozilla/5.0'} r=requests.post(base_url+'/post',data=form_data,headers=header) print(r.text) 返回值 { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"passwd\": \"8888\", \"user\": \"zxw\" }, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Connection\": \"close\", \"Content-Length\": \"20\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"User-Agent\": \"Mozilla/5.0\" }, \"json\": null, \"origin\": \"110.52.2.106\", \"url\": \"http://httpbin.org/post\" } Tips：很多爬虫程序都会定制 headers 来避免被封,如下面爬取知乎页面元素就设置了请求头。 headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36' } r = requests.get(\"https://www.zhihu.com/explore\",headers=headers) print(r.text) 响应内容 当请求发送成功之后，我们可以获取响应内容。如响应状态码，响应头信息、响应体内容。 form_data = {'user': 'zxw', 'passwd': '8888'} header={'user-agent':'Mozilla/5.0'} r=requests.post(base_url+'/post',data=form_data,headers=header) #获取响应状态码 print(r.status_code) #获取响应头信息 print(r.headers) #获取响应内容 print(r.text) #将响应的内容以 Json 格式返回 print(r.json()) 返回结果 200 {'Access-Control-Allow-Origin': '*', 'Content-Length': '342', 'Access-Control-Allow-Credentials': 'true', 'Content-Type': 'application/json', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.8.1', 'Date': 'Wed, 18 Jul 2018 06:33:55 GMT', 'Via': '1.1 vegur'} {\"args\":{},\"data\":\"\",\"files\":{},\"form\":{\"passwd\":\"8888\",\"user\":\"zxw\"},\"headers\":{\"Accept\":\"*/*\",\"Accept-E ncoding\":\"gzip, deflate\",\"Connection\":\"close\",\"Content-Length\":\"20\",\"Content-Type\":\"application/x-www-form-urlencoded\",\"H ost\":\"httpbin.org\",\"User-Agent\":\"Mozilla/5.0\"},\"json\":null,\"origin\":\"110.52.2.106\",\"url\":\"http://httpbin. org/post\"} {'files': {}, 'origin': '110.52.2.106', 'json': None, 'data': '', 'url': 'http://httpbin.org/post', 'headers': {'User-Agent': 'Mozilla/5.0', 'Content-Length': '20', 'Accept': '*/*', 'Content-Type': 'application/x-www-form-urlencoded', 'Host': 'httpbin.org', 'Connection': 'close', 'Accept-Encoding': 'gzip, deflate'}, 'form': {'passwd': '8888', 'user': 'zxw'}, 'args': {}} Requests 进阶应用 Cookie 设置 设置 cookie 通过 cookies 参数可以设置 Cookie request_advance.py import requests cookie={'user':'51zxw'} r=requests.get(base_url+'/cookies',cookies=cookie) print(r.text) 运行结果： {\"cookies\":{\"user\":\"51zxw\"}} 获取 cookie 请求百度首页，然后获取 cookie，实现如下： # 获取 cookie r=requests.get('http://www.baidu.com') print(type(r.cookies)) print(r.cookies) for key,value in r.cookies.items(): print(key+':'+value) 运行结果： ]> BDORZ:27315 调用了 cookies 属性即可成功得到了 Cookies，可以发现它是一个 RequestCookieJar 类型，然后我们 用 items() 方法将其转化为元组组成的列表，遍历输出每一个 Cookie 的名和值，实现 Cookies 的遍历解析。 超时 你可以让 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。防止某些请求没有响应而一直处于 等待状态。 下面案例故意设置一个很小的超时时间，为了来看一下超时后的一个响应处理，但是实际测试过程中不要设置这短。 r=requests.get(base_url+'/cookies',cookies=cookies,timeout=0.001) print(r.text) 超时响应异常 raise ConnectTimeout(e, request=request) requests.exceptions.ConnectTimeout: HTTPConnectionPool(host='httpbin.org', port=80): Max retries exceeded with url: /cookies (Caused by ConnectTimeoutError(, 'Connection to httpbin.org timed out. (connect timeout=0.001)')) 文件上传 Reqeuests 可以使用参数 files 模拟提交一些文件数据，假如有的接口需要我们上传文件，我们同样可以利用它来 上传，实现非常简单，实例如下： #上传文件 file={'file':open('zxw_logo.png','rb')} r=requests.post(base_url+'/post',files=file) print(r.text) 会话对象 会话(Session) 在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。 这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会 话中一直存在下去。 比如你先进行了登录操作，然后打开个人中心详情页面，个人中心详情页面如何知道展示的是刚刚登录的这个用户 的信息，那么这里就需要使用 Session 来存储相关信息。 在接口测试过程中接口之间经常有依赖关系，比如下面这两个请求一个是设置 Cookie,另外一个是获取 cookie,在没 有 Session 保存机制的情况下，第二个接口无法获取第一个接口设置的 Cookie 值。 #设置 cookie r=requests.get(base_url+'/cookies/set/user/51zxw') print(r.text) #获取 Cookie r=requests.get(base_url+'/cookies') print(r.text) 响应数据 { \"cookies\": { \"user\": \"51zxw\" } } { \"cookies\": {} } Request 的会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie。具体使用如下： #生成会话对象 s=requests.Session() #设置 Cookie r=s.get(base_url+'/cookies/set/user/51zxw') print(r.text) #获取 Cookie r=s.get(base_url+'/cookies') print(r.text) 运行结果 { \"cookies\": { \"user\": \"51zxw\" } } { \"cookies\": { \"user\": \"51zxw\" } } 所以，利用 Session 我们可以做到模拟同一个会话，而且不用担心 Cookies 的问题，通常用于模拟登录成功之 后再进行下一步的操作。 SSL 证书验证 Requests 可以为 HTTPS 请求验证 SSL 证书，就像 web 浏览器一样。SSL 验证默认是开启的，如果证书验证 失败，Requests 会抛出 SSLError: 如果不想验证 SSL 则可以使用 verify 参数关闭验证 SSL。 下面是验证 12306 网站的证书。 r=requests.get('https://www.12306.cn') #关闭验证 SSL #r=requests.get('https://www.12306.cn',verify=False) print(r.text) 运行结果： raise SSLError(e, request=request) requests.exceptions.SSLError: HTTPSConnectionPool(host='www.12306.cn', port=443): Max retries exceeded with url: / (Caused by SSLError(CertificateError(\"hostname 'www.12306.cn' doesn't match either of 'webssl Tips：12306 的证书是自己颁发给自己的，所以会出现认证失败。 代理设置 代理简介 代理（Proxy），也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另 一个网络终端（一般为服务器）进行非直接的连接。 代理服务器位于客户端和访问互联网之间，服务器接收客户端的请求，然后代替客户端向目标网站发出请求，所有 的流量路由均来自代理服务器的 IP 地址，从而获取到一些不能直接获取的资源。 对于有些接口，在测试的时候请求几次，能正常获取内容。但是一旦开始大规模频繁请求（如性能测试）服务器可 能会开启验证，甚至直接把 IP 给封禁掉。 那么为了防止这种情况的发生，我们就需要设置代理来解决这个问题， 在 Requests 中需要用到 proxies 这个参数，在爬虫中会常用到代理。 西刺免费代理 IP #代理设置 proxies={'http':'http://219.141.153.41:80'} r=requests.get(base_url+'/get',proxies=proxies) print(r.text) 运行结果如下：可以看到 origin 参数即为我们设置的代理 ip { \"args\": {}, \"headers\": { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"en-US,en;q=0.5\", \"Cache-Control\": \"max-age=86400\", \"Connection\": \"close\", \"Host\": \"httpbin.org\", \"User-Agent\": \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\" }, \"origin\": \"219.141.153.41\", \"url\": \"http://httpbin.org/get\" } 身份认证 很多接口都需要身份认证，Requests 支持多种身份认证，具体使用方法如下: 下面案例主要验证了 2 种身份类型：BasicAuth 和 digestAuth from requests.auth import HTTPBasicAuth from requests.auth import HTTPDigestAuth #身份认证-BasicAuth r=requests.get(base_url+'/basic-auth/51zxw/8888',auth=HTTPBasicAuth('51zxw','8888')) print(r.text) #身份认证——DigestAuth r=requests.get(base_url+'/digest-auth/auth/zxw/6666',auth=HTTPDigestAuth('zxw','6666')) print(r.text) 运行结果： {\"authenticated\":true,\"user\":\"51zxw\"} {\"authenticated\":true,\"user\":\"zxw\"} 流式请求 有一些接口返回值比较特殊，不是单纯返回一个结果，而是多个结果,比如某个查询接口，返回值为排行榜前 10 的 商品信息。 实践案例 请求接口如下： http://httpbin.org/stream/{num} num 表示返回结果集的数量，比如输入 10 则会返回 10 个下面这种不同 id 的结果 {\"url\": \"http://httpbin.org/stream/10\", \"args\": {}, \"headers\": {\"Host\": \"httpbin.org\", \"Connection\": \"close\", \"Accept\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36 LBBROWSER\", \"Referer\": \"http://httpbin.org/\", \"Accept-Encoding\": \"gzip, deflate, sdch\", \"Accept-Language\": \"zh-CN,zh;q=0.8\", \"Cookie\": \"_gauges_unique_hour=1; _gauges_unique_day=1; _gauges_unique_month=1; _gauges_unique_year=1; _gauges_unique=1\"}, \"origin\": \"110.52.4.234\", \"id\": 0} {\"url\": \"http://httpbin.org/stream/10\", \"args\": {}, \"headers\": {\"Host\": \"httpbin.org\", \"Connection\": \"close\", \"Accept\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36 LBBROWSER\", \"Referer\": \"http://httpbin.org/\", \"Accept-Encoding\": \"gzip, deflate, sdch\", \"Accept-Language\": \"zh-CN,zh;q=0.8\", \"Cookie\": \"_gauges_unique_hour=1; _gauges_unique_day=1; _gauges_unique_month=1; _gauges_unique_year=1; _gauges_unique=1\"}, \"origin\": \"110.52.4.234\", \"id\": 1} {\"url\": \"http://httpbin.org/stream/10\", \"args\": {}, \"headers\": {\"Host\": \"httpbin.org\", \"Connection\": \"close\", \"Accept\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36 LBBROWSER\", \"Referer\": \"http://httpbin.org/\", \"Accept-Encoding\": \"gzip, deflate, sdch\", \"Accept-Language\": \"zh-CN,zh;q=0.8\", \"Cookie\": \"_gauges_unique_hour=1; _gauges_unique_day=1; _gauges_unique_month=1; _gauges_unique_year=1; _gauges_unique=1\"}, \"origin\": \"110.52.4.234\", \"id\": 2} 更多内容省略 ... 针对这种类型的接口我们对结果集的处理需要使用迭代方法 iter_lines()来处理,具体使用如下： import json r=requests.get(base_url+'/stream/10',stream=True) #如果响应内容没有设置编码，则默认设置为 utf-8 if r.encoding is None: r.encoding='utf-8' #对响应结果进行迭代处理 for line in r.iter_lines(decode_unicode=True): if line: data=json.loads(line) print(data['id']) 返回结果： 0 1 2 3 4 5 6 7 8 9 参考资料 http://docs.python-requests.org/zh_CN/latest/user/quickstart.html#id2 https://germey.gitbooks.io/python3webspider/content/3.2.3-高级用法.html By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第三章/Python接口测试实践——基于天气API.html":{"url":"第三章/Python接口测试实践——基于天气API.html","title":"第2节：Python接口测试实践——基于天气API","keywords":"","body":"第2节：Python接口测试实践——基于天气API 测试案例 测试 API 测试的 API 为：天气 API • 接口 URL：https://www.sojson.com/open/api/weather/json.shtml • 请求方式:GET • 参数：city 为城市名称(仅支持国内城市)，支持的城市可以带上市、县、区之类,如：北京,深圳、南山区、 长沙市、长沙等等。 • 返回值格式如下(查询城市为北京)： { \"date\": \"20180815\", \"message\": \"Success !\", \"status\": 200, \"city\": \"北京\", \"count\": 22, \"data\": { \"shidu\": \"86%\", \"pm25\": 13.0, \"pm10\": 27.0, \"quality\": \"优\", \"wendu\": \"25\", \"ganmao\": \"各类人群可自由活动\", \"yesterday\": { \"date\": \"14 日星期二\", \"sunrise\": \"05:23\", \"high\": \"高温 29.0℃\", \"low\": \"低温 24.0℃\", \"sunset\": \"19:14\", \"aqi\": 20.0, \"fx\": \"东风\", \"fl\": \"测试场景 通过接口来查询 北京 的天气信息 代码实现 weather_api_test.py import requests from urllib import parse #构造接口测试数据 data={'city':'北京'} city=parse.urlencode(data).encode('utf-8') url='https://www.sojson.com/open/api/weather/json.shtml' #发送请求 r=requests.get(url,params=city) # print(r.text) #将返回结果转化为 Json 类型 response_data=r.json()#分别获取日期，响应信息，状态、和城市 print(response_data['date']) print(response_data['message']) print(response_data['status']) print(response_data['city']) #获取当日天气 print(response_data['data']['forecast'][0]['date']) print(response_data['data']['forecast'][0]['type']) print(response_data['data']['forecast'][0]['high']) print(response_data['data']['forecast'][0]['low']) 注意： • 每个 IP 日调用额度 2000 次，超过过多，会直接封掉 IP 段。 • 每次请求间隔必须 3 秒一次，如果多次超过 3 秒内调用多次，会封掉 IP 段 • 更多注意事项 集成到 Unittest 应用背景 上面的案例只是针对单个场景进了接口调用，但是实际的接口测试需要针对不同的参数场景进行测试。另外还需要设置断言，生成测试报告。 用例设计 代码实现 weather_api_unittest.py import unittest import requests from urllib import parse from time import sleep class WeatherTest(unittest.TestCase): def setUp(self): self.url='https://www.sojson.com/open/api/weather/json.shtml' #代理设置，避免 ip 被封 # self.proxies={'http':'http://125.118.146.222:6666'} def test_weather_beijing(self): '''测试北京天气''' data = {'city': '北京'} city = parse.urlencode(data).encode('utf-8') # r=requests.get(self.url,params=city,proxies=self.proxies) r=requests.get(self.url,params=city) result=r.json() #断言 self.assertEqual(result['status'],200) self.assertEqual(result['message'],'Success !') self.assertEqual(result['city'],'北京') #设置间隔时间，避免 ip 被封 sleep(3) def test_weather_param_error(self): '''参数异常''' data={'city':'666'} # r=requests.get(self.url,params=data,proxies=self.proxies) r=requests.get(self.url,params=data) result=r.json() self.assertEqual(result['message'],'Check the parameters.') sleep(3) def test_weather_no_param(self): '''参数缺省''' # r=requests.get(self.url,params=data,proxies=self.proxies) r=requests.get(self.url) result=r.json() self.assertEqual(result['message'],'Check the parameters.') self.assertEqual(result['status'],400) sleep(3) if __name__ == '__main__': unittest.main() 运行结果： C:\\Python35\\python.exe D:/api_test/requests_api_test/weather_api_unittest.py ... ---------------------------------------------------------------------- Ran 3 tests in 10.312s OK Process finished with exit code 0\\ 生成测试报告 • 首先创建文件夹 reports 和 test_case • 下载 BSTestRunner • 创建 run.py 模块 run.py import unittest from BSTestRunner import BSTestRunner import time #指定测试用例和测试报告的路径 test_dir = './test_case' report_dir = './reports' #加载测试用例 discover = unittest.defaultTestLoader.discover(test_dir, pattern='test_weather.py') #定义报告的文件格式 now = time.strftime(\"%Y-%m-%d %H_%M_%S\") report_name = report_dir + '/' + now + ' test_report.html' #运行用例并生成测试报告 with open(report_name, 'wb') as f: runner = BSTestRunner(stream=f, title=\"Weather API Test Report\", description=\"China City Weather TestReport\") runner.run(discover) 运行之后可以看到测试报告如下： By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第三章/Restful接口开发与测试.html":{"url":"第三章/Restful接口开发与测试.html","title":"第3节：Restful接口开发与测试","keywords":"","body":"第3节：Restful接口开发与测试 Rest 概述 简介 • REST 是英文 Representational State Transfer(表现层状态转化)，Rest 是 web 服务的一种架构风格; • 使用 HTTP,URI、XML、JSON、HTML 等广泛流行的标准和协议;轻量级,跨平台、跨语言的架构设计; • 它是一种设计风格,不是一种标准,是一种思想。 Rest 原则 • 网络上的所有事物都可以被抽象为资源(resource)。 • 每一个资源都有唯一的资源标识(resource identifier)，对资源的操作不会改变这些标识 • 所有的操作都是无状态的。 设计思想 REST 简化开发，其架构遵循 CRUD 原则，该原则告诉我们对于资源(包括网络资源)只需要四种行为：创建，获取， 更新和删除就可以完成相关的操作和处理。 我们可以通过统一资源标识符（Universal Resource Identifier，URI）来识别和定位资源，并且针对这些资源而 执行的操作是通过 HTTP 规范定义的。其核心操作只有 GET,POST,PUT,DELETE。也就是：URL 定位资源，用 HTTP动词（GET,POST,DELETE,DETC）描述操作。 因此设计 web 接口的时候，REST 主要是用于定义接口名，接口名一般是用名次写，不用动词，那怎么表达“获取” 或者“删除”或者“更新”这样的操作呢——用请求类型（GET,PUT,POST,DELETE）来区分。 案例 比如我们设计一个用户管理系统的接口，如果不使用 Restful 风格，接口会定义如下： http://127.0.0.1/user/query/1 #根据用户 id 查询用户数据 GET 请求 http://127.0.0.1/user/adduser #新增用户 Post 请求 http://127.0.0.1/user/update #修改用户信息 PUT 请求 http://127.0.0.1/user/delete #删除用户信息 DELETE 请求 从上面的定义接口来看貌似没有什么问题，但是仔细揣测就会发现有一些瑕疵：比如查询方法定义接口使用了 query动词，而 GET 请求本身的含义也就是从服务器获取资源，带有查询的含义，如果接口里面定义又加上这样的动词显得重复，同理其他几个接口也是一样的。 而使用 Rest 接口定义如下： http://127.0.0.1/user/1 #GET 根据用户 id 查询用户数据 http://127.0.0.1/user #POST 新增用户 http://127.0.0.1/user #PUT 修改用户信息 http://127.0.0.1/user #DELETE 删除用户信息 从上面定义的接口我们可以看出，接口名称主要指向 user 资源，具体的资源操作（增删改查）由 HTTP 的请求类型来定义。这样接口名称显得统一整洁，就不用定义不同的接口名称。 遵循这样一种风格的 Reset 接口就叫做Restful。 HTTP 方法幂等性与安全性 • 幂等：对同一 Rest 接口多次请求，得到的资源状态是相同的。 • 安全：对该 Rest 接口请求，不会使服务器资源状态发生改变。 Rest 优势 由于 REST 强制所有的操作都必须是无状态的，这就没有上下文的约束，如果做分布式，集群都不需要考虑上下文和会话保持的问题。极大的提高系统的可伸缩性。 前后端分离。前端拿到数据只负责展示和渲染，不对数据做任何处理。后端处理数据并以 JSON 格式传输出去，定义这样一套统一的接口，在 web，ios，android 三端都可以用相同的接口。 Django 接口开发 Django 简介 Django 是一个开放源代码的 Web 应用框架，由 Python 写成。采用了 MVC 的框架模式，即模型 M，视图 V 和控制器 C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是 CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。 • 官网地址：https://www.djangoproject.com • 官方文档(中文)：https://docs.djangoproject.com/zh-hans/2.0/ Tips：Python 的 Web 开发框架除了 Django，还有 Flask 和 Tornado 等。 Django 安装 输入如下命令即可安装 Django，注意需要提前配置好 Python 环境，这里选择的 django 版本是 2.0.3 版本， pip install django 安装校验：在 Windows 命令提示符下输入 django-admin 命令回车。 提示如下内容则说明安装成功 C:\\Users\\Shuqing>django-admin Type 'django-admin help ' for help on a specific subcommand. Available subcommands: [django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate runserver sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserver Note that only Django core commands are listed as settings are not properly configured (error: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.) Django REST Framework 简介 Django REST Framework，是一套基于 Django 的 REST 风格的框架。 官方主页：http://www.django-rest-framework.org 特点 • 功能强大、灵活，可以帮助你快速开发 Web API。 • 支持认证策略，包括 OAuth1 和 OAuth2。 • 支持 ORM(对象关系映射)和非 ORM 数据源的序列化。 • 丰富的文档以及良好的社区支持。 安装 pip install djangorestframework #Django REST Framework pip install markdown # Markdown support for the browsable API. pip install django-filter # Filtering support 创建 API 项目创建 当 Django REST Framework 安装好之后，创建一个新的项目 django_restful，如下命令所示我是创建在 D 盘根目录。在项目下创建 api 应用 C:\\Users\\Shuqing>d: #创建一个新的项目 D:\\>django-admin startproject django_restful 进入项目 django_restful 创建 api 应用,创建完成之后可以看到项目文件夹下面多了一个 api 文件夹 D:\\>cd django_restful D:\\django_restful>python manage.py startapp api 进入到 D:\\django_rest\\django_restful 目录，打开 settings.py 在项目下创建 api 和 rest_framework。 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'api', ] rest_framework 权限配置 默认的权限策略可以设置在全局范围内，通过 DEFAULT_PERMISSION_CLASSES 设置。在该文件末尾添加如下容： REST_FRAMEWORK = { 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', ) } 数据库迁移 然后通过命令 migrate 命令进行数据库迁移。 D:\\django_restful>python manage.py migrate 执行之后看到如下提示说明迁移成功 Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying sessions.0001_initial... OK 创建超级管理员 使用 createsuperuser 命令来创建超级管理员账户，密码至少 8 位数字和字母组合。如 51zxw20182018 D:\\django_rest>python manage.py createsuperuser Username (leave blank to use 'shuqing'): 51zxw Email address: 51zxw@163.com Password: Password (again): Superuser created successfully. 启动 Server 启动 django，然后验证登录我们创建的超级管理员账户。 D:\\django_rest>python manage.py runserver Performing system checks... System check identified no issues (0 silenced). July 20, 2018 - 16:01:39 Django version 2.0.7, using settings 'django_rest.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CTRL-BREAK. 启动成功之后，输入地址:http://127.0.0.1:8000/ 我们可以看到如下页面： Tips：也可以自定义 host 和 port,如下所示： python manage.py runserver 127.0.0.1:8001 登录超级管理员账户 我们再输入地址：http://127.0.0.1:8000/admin 即可进入到登录超级管理员账户界面： 登录我们创建的账户，可以看到如下界面： 数据序列化 Serializers 用于定义 API 的表现形式，如返回哪些字段、返回怎样的格式等。这里序列化 Django 自带的 User 和 Group。创建数据序列化，在 api 应用下创建 serializers.py 文件。 序列化代码如下： serializers.py from django.contrib.auth.models import User,Group from rest_framework import serializers class UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model=User fields=('url','username','email','groups') class GroupSerializer(serializers.HyperlinkedModelSerializer): class Meta: model=Group fields=('url','name') 创建视图 视图用于如何向用户展示数据，展示哪些数据。比如用户查询 User 信息或查询 Group 信息，那么程序内部要定义好 怎么去查询。在 Django REST framework 中，ViewSets 用于定义视图的展现形式，例如返回哪些内容，需要做哪 些权限处理。 打开 api 应用下的 views.py 文件，编写如下代码: views.py from django.shortcuts import render from django.contrib.auth.models import User,Group from rest_framework import viewsets from api.serializers import UserSerializer,GroupSerializer # Create your views here. class UserViewSet(viewsets.ModelViewSet): queryset = User.objects.all() serializer_class = UserSerializer class GroupViewSet(viewsets.ModelViewSet): queryset = Group.objects.all() serializer_class = GroupSerializer 在 URL 中会定义相应的规则到 ViewSets。ViewSets 则通过 serializer_class 找到对应的 Serializers。 这里将 User 和 Group 的所有对象赋予 queryset，并返回这些值。在 UserSerializer 和 GroupSerializer 中定义要返回的字段。 URL 路由配置 打开.../django_rest/urls.py 文件，添加 api 的路由配置。 from django.contrib import admin from django.urls import path from django.conf.urls import include from rest_framework import routers from api import views router=routers.DefaultRouter() router.register(r'users',views.UserViewSet) router.register(r'groups',views.GroupViewSet) urlpatterns = [ path('admin/', admin.site.urls), path('',include(router.urls)), path('api-auth/',include('rest_framework.urls',namespace='rest_framework')), ] 注意：Django1.0 和 2.0 关于路由配置写法有一些区别,使用 1.0 路由配置如下 from django.conf.urls import url urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^',include(router.urls)), url(r'^api-auth/',include('rest_framework.urls',namespace='rest_framework')), ] 打开 API 主页 启动服务，然后在浏览器打开：http://127.0.0.1:8000/ 即可看到 API 主页，如下所示： 创建数据 点击主页右上角的 Log in 登录超级管理员账户，然后分别创建 Group 和 User 数据。 Tips: Vary: Accept 标头可告诉代理服务器缓存两种版本的资源：压缩和非压缩，这有助于避免一些公共代理不能 正确地检测 Content-Encoding 标头的问题。 Swagger 接口文档生成 接口开发完成了，那么接下来需要编 写接口文档。传统的接口文档编写都是使用 Word 或者其他一些接口文档管理 平台，这种形式接口文档维护更新比较麻烦，每次接口有变动时得手动修改文档。因此，针对这种情况，这里推荐 使用 Swagger 来管理接口文档。 Swagger 简介 Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统(源代码)作为服务器以同样的速度来更新。每当接口有变动时，对应的接口文档也会自动更新。 Tips：(http://httpbin.org/#/) 也是利用 Swagger 生成接口文档。 Swagger 能成为最受欢迎的 REST APIs 文档生成工具之一，有以下几个原因： • Swagger 可以生成一个具有互动性的 API 控制台，开发者可以用来快速学习和尝试 API。 • Swagger 可以生成客户端 SDK 代码用于各种不同的平台上的实现。 • Swagger 文件可以在许多不同的平台上从代码注释中自动生成。 • Swagger 有一个强大的社区，里面有许多强悍的贡献者。 Django 接入 Swagger 首先安装 django-rest-swagger pip install django-rest-swagger 进入到 setting.py 文件，添加 django-rest-swagger 应用 # Application definition INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'api', 'rest_framework_swagger', ] 进入到 views.py 将之前定义的 UserViewSet 和 GroupViewSet 补充注释： from django.contrib.auth.models import User,Group from rest_framework import viewsets from api.serializers import UserSerializer,GroupSerializer # Create your views here. class UserViewSet(viewsets.ModelViewSet): \"\"\" retrieve: Return a user instance. list: Return all users, ordered by most recently joined. create: Create a new user. delete: Remove an existing user. partial_update: Update one or more fields on an existing user. update: Update a user. \"\"\" queryset = User.objects.all() serializer_class = UserSerializer class GroupViewSet(viewsets.ModelViewSet): \"\"\" retrieve: Return a group instance. list: Return all groups, ordered by most recently joined. create: Create a new group. delete: Remove an existing group. partial_update: Update one or more fields on an existing group. update: Update a group. \"\"\" queryset = Group.objects.all() serializer_class = GroupSerializer 在 urls.py 添加 get_schema_view 辅助函数 from rest_framework.schemas import get_schema_view from rest_framework_swagger.renderers import SwaggerUIRenderer,OpenAPIRenderer schema_view=get_schema_view(title='API',renderer_classes=[OpenAPIRenderer,SwaggerUIRenderer]) urlpatterns = [ path('admin/', admin.site.urls), path('',include(router.urls)), path('api-auth/',include('rest_framework.urls',namespace='rest_framework')), path('docs/',schema_view,name='docs') ] 启动服务，然后打开地址：http://127.0.0.1:8000/docs/ 即可看到如下界面： 分别点击 groups 和 users 即可看到自动生成的接口文档。 Restful 接口测试 开发完接口，接下来我们需要对我们开发的接口进行测试。接口测试的方法比较多，使用接口工具或者 Python 来 测试都可以，工具方面比如之前我们学习过的 Postman 或者 Jmeter ，Python 脚本测试可以使用 Requests + unittest来测试。 测试思路 • 功能测试：数据的增删改查 • 异常测试：未授权，参数异常等 Postman 测试 使用测试工具 Postman 测试结果如下所示： user 接口测试 查询所有用户 创建用户 修改用户 删除用户 未授权测试 groups 接口测试 查询所有 groups 数据 修改 group 数据 删除 groups Requests+Unittest 在 api 目录下面新建一个 test_unittest.py，代码实现如下: tests_unittest.py import requests import unittest class UserTest(unittest.TestCase): def setUp(self): self.base_url='http://127.0.0.1:8000/users' self.auth=('51zxw','zxw20182018') def test_get_user(self): r=requests.get(self.base_url+'/1/',auth=self.auth) result=r.json() self.assertEqual(result['username'],'51zxw') self.assertEqual(result['email'],'51zxw@163.com') def test_add_user(self): form_data={'username':'zxw222','email':'zxw668@qq.com','groups':'http://127.0.0.1:8000/groups/2/'} r=requests.post(self.base_url+'/',data=form_data,auth=self.auth) result=r.json() self.assertEqual(result['username'],'zxw222') def test_delete_user(self): r=requests.delete(self.base_url+'/11/',auth=self.auth) self.assertEqual(r.status_code,204) def test_update_user(self): form_data={'email':'2222@163.com'} r=requests.patch(self.base_url+'/2/',auth=self.auth,data=form_data) result=r.json() self.assertEqual(result['email'],'2222@163.com') def test_no_auth(self): r=requests.get(self.base_url) result=r.json() self.assertEqual(result['detail'],'Authentication credentials were not provided.') class GroupTest(unittest.TestCase): def setUp(self): self.base_url='http://127.0.0.1:8000/groups' self.auth=('51zxw','zxw20182018') def test_group_developer(self): r=requests.get(self.base_url+'/7/',auth=self.auth) result=r.json() self.assertEqual(result['name'],'Developer') def test_add_group(self): form_data={'name':'Pm'} r=requests.post(self.base_url+'/',auth=self.auth,data=form_data) result=r.json() self.assertEqual(result['name'],'Pm') def test_update_group(self): form_data={'name':'Boss'} r=requests.patch(self.base_url+'/6/',auth=self.auth,data=form_data) result=r.json() self.assertEqual(result['name'],'Boss') def test_detele_group(self): r=requests.delete(self.base_url+'/6/',auth=self.auth) self.assertEqual(r.status_code,204) if __name__ == '__main__': unittest.main() Django 自带测试模块 打开 api 目录下面的 tests 文件，编写如下测试代码 tests.py from django.test import TestCase import requests # Create your tests here. class UserTest(TestCase): def setUp(self): self.base_url='http://127.0.0.1:8000/users' self.auth=('51zxw','xxxxx') def test_get_user(self): r=requests.get(self.base_url+'/1/',auth=self.auth) result=r.json() self.assertEqual(result['username'],'51zxw') self.assertEqual(result['email'],'zxw886@qq.com') # @unittest.skip('skip add user') def test_add_user(self): form_data={'username':'zxw222','email':'zxw668@qq.com','groups':'http://127.0.0.1:8000/groups/2/'} r=requests.post(self.base_url+'/',data=form_data,auth=self.auth) result=r.json() self.assertEqual(result['username'],'zxw222') # @unittest.skip('skip test_delete_user') def test_delete_user(self): r=requests.delete(self.base_url+'/11/',auth=self.auth) self.assertEqual(r.status_code,204) def test_update_user(self): form_data={'email':'2222@163.com'} r=requests.patch(self.base_url+'/2/',auth=self.auth,data=form_data) result=r.json() self.assertEqual(result['email'],'2222@163.com') def test_user_already_exists(self): form_data = {'username': 'zxw222', 'email': 'zxw668@qq.com', 'groups': 'http://127.0.0.1:8000/groups/2/'} r = requests.post(self.base_url + '/', data=form_data, auth=self.auth) result = r.json() #预期返回值：{\"username\":[\"A user with that username already exists.\"]} self.assertEqual(result['username'][0], 'A user with that username already exists.') def test_no_auth(self): r=requests.get(self.base_url) result=r.json() self.assertEqual(result['detail'],'Authentication credentials were not provided.') class GroupTest(TestCase): def setUp(self): self.base_url='http://127.0.0.1:8000/groups' self.auth=('51zxw','xxxxxx') def test_group_developer(self): r=requests.get(self.base_url+'/3/',auth=self.auth) result=r.json() self.assertEqual(result['name'],'Pm') # @unittest.skip('skip test_add_group') def test_add_group(self): form_data={'name':'Leader'} r=requests.post(self.base_url+'/',auth=self.auth,data=form_data) result=r.json() self.assertEqual(result['name'],'Leader') def test_update_group(self): form_data={'name':'Boss'} r=requests.patch(self.base_url+'/6/',auth=self.auth,data=form_data) result=r.json() self.assertEqual(result['name'],'Boss') def test_detele_group(self): r=requests.delete(self.base_url+'/6/',auth=self.auth) self.assertEqual(r.status_code,204) 运行方式：打开 cmd 使用如下命令来运行即可： D:\\django_restful>python manage.py test 上面命令是默认测试全部的用例，如果想测试部分用例则可以使用如下命令： 测试指定的测试类 D:\\django_restful>python manage.py test api.tests.UserTest 测试具体的某一条具体用例 D:\\django_restful>python manage.py test api.tests.UserTest.test_get_user 参考资料 • https://blog.csdn.net/chenxiaochan/article/details/73716617 • https://www.cnblogs.com/liang1101/p/6266305.html • https://segmentfault.com/q/1010000009125740/a-1020000009128940 • https://baike.baidu.com/item/django/61531?fr=aladdin • https://www.jianshu.com/p/dc77f652e7d7 • https://segmentfault.com/q/1010000005685904/ By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第三章/Django数据管理.html":{"url":"第三章/Django数据管理.html","title":"第4节：Django数据管理","keywords":"","body":"第4节：Django数据管理 问题思考 在接口测试过程中，由于有些接口类型并不是安全的，比如 DELETE 类型，上一次请求之后下一次再请求结果就不一 样了。甚至有时接口之间的数据还会相互干扰， 导致接口断言失败时不能断定到底是接口程序引起的错误，还是测试数据变化引起的错误，那么该如何有效解决这个问题呢？ 解决思路 通过测试数据库，每轮测试之前将数据初始化，这样避免数据干扰。 Django 数据库管理 在之前我们的接口项目 django_resutful 使用的数据库是 Python 自带的 SQLite3。 Django 还支持以下几种数据库： • PostgreSQL • MySQL • Oracle 接下来我们将会以 Mysql 来进行演示。 mysql 简介 MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是 最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL 是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。 mysql 下载安装 下载地址：https://dev.mysql.com/downloads/installer/ 安装教程：自学网-Mysql 教程 Navicat Navicat 是一套数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。Navicat 是以直觉化的图形用户界面而建的，让你可以以安全并且简单的方式创建、组织、访问并共用信息。 Django 迁移 MySql 修改 Setting 配置 首先打开 setting.py 将 DATABASES 修改如下： DATABASES = { 'default': { # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'ENGINE':'django.db.backends.mysql', 'HOST':'127.0.0.1', 'PORT':'3306', 'NAME':'django_restful', 'USER':'root', 'PASSWORD':'', 'OPTIONS':{ 'isolation_level':None, 'init_command': \"SET sql_mode='STRICT_TRANS_TABLES'\", }, } } 也就是将原来 sqllite 换成 Mysql 安装 MySQLdb 驱动 再打开 djangorestful 中的_init.py，添加如下代码： import pymysql pymysql.install_as_MySQLdb() 上面代码表示安装 MySQLdb 驱动。 连接数据库 使用 Navicat 连接数据库如下所示： 然后创建数据库 django_restful 创建 Models Django 提供了完善的模型（model）层来创建和存取数据，它包含你所储存数据的必要字段和行为。通常，每个模型对应数据库中唯一的一张表。 打开 api 中的 models.py 创建如下代码： from django.db import models # Create your models here. class User(models.Model): username=models.CharField(max_length=100) email=models.CharField(max_length=100) groups=models.CharField(max_length=100) def __str__(self): return self.username class Group(models.Model): name=models.CharField(max_length=100) def __str__(self): return self.name 上面代码表示创建数据库的表，一个是 User，另外一个是 Group 其中 def __str__()的作用是美化字段的显示，方便查看。如果没有st方法，显示的结果是类似 Django 模型字段常用类型 导入 Models 创建好 Model 后需要分别在 serializers.py 和 views.py 来导入，同时去掉 danjo 默认的数据库。 serializers.py # from django.contrib.auth.models import User,Group from rest_framework import serializers from api.models import User,Group views.py # from django.contrib.auth.models import User,Group from rest_framework import viewsets from api.serializers import UserSerializer,GroupSerializer from api.models import User,Group 数据库迁移 python manage.py makemigrations api python manage.py migrate 迁移完成之后需要重新设置一个超级管理员账户，然后登录。 python manage.py createsuperuser 数据库初始化 封装初始化操作 数据初始化操作主要包括：数据库连接，数据清除、数据插入、关闭数据库。 在 api 项目下面新建一个目录 test_project 然后创建文件：mysql_action.py 扩展资料：SQL 命令教程 from pymysql import connect import yaml class DB(): def __init__(self): '''连接数据库''' print('connect db') self.conn=connect(host='127.0.0.1',user='root', password='',db='django_restful') def clear(self,table_name): '''清除表中数据''' print('clear db...') clear_sql = 'truncate ' + table_name + ';' with self.conn.cursor() as cursor: #清除外键约束 cursor.execute(\"set foreign_key_checks=0;\") cursor.execute(clear_sql) self.conn.commit() def insert(self, table_name, table_data): '''插入数据''' print('insert db...') #遍历数据 for key in table_data: table_data[key] = \"'\" + str(table_data[key]) + \"'\" key = ','.join(table_data.keys()) value = ','.join(table_data.values()) print(key) print(value) insert_sql = \"insert into \" + table_name + \"(\" + key + \")\" + \"values\" + \"(\" + value + \")\" print(inser_sql) with self.conn.cursor() as cursor: cursor.execute(insert_sql) self.conn.commit() def close(self): '''关闭数据库连接''' print('close db') self.conn.close() def init_data(self, datas): '''初始化数据''' print('init db...') for table, data in datas.items(): self.clear(table) for d in data: self.insert(table, d) self.close() if __name__ == '__main__': db=DB() #调试各个方法 db.clear('api_user') db.clear('api_group') user_data={'id':1,'username':'51zxw','email':'51zxw@163.com'} db.insert('api_user',user_data) group_data={'id':1,'name':'Developer'} db.insert('api_group',group_data) db.close() #初始化数据 f=open('datas.yaml','r') datas=yaml.load(f) db.init_data(datas) 封装初始化数据 我们将初始化数据使用 Yaml 来封装，可以将数据与代码分离，方便测试数据的维护。在 test_project 目录中创建datas.yaml 数据内容如下： api_user: - id: 1 username: sutune email: sutune@163.com groups: http://127.0.0.1:8000/groups/1/ - id: 2 username: 51zxw email: 51zxw@163.com groups: http://127.0.0.1:8000/groups/2/ api_group: - id: 1 name: Developer - id: 2 name: Tester 扩展资料： Appium yaml 教程 5-1~5-4 执行初始化后数据如下： 测试用例封装 在 test_project 下面创建一个测试模块 test_diango_restful.py test_django_restful.py import requests import unittest from mysql_action import DB import yaml class UserTest(unittest.TestCase): def setUp(self): self.base_url='http://127.0.0.1:8000/users' self.auth=('51zxw','zxw20182018') def test_001_get_user(self): r=requests.get(self.base_url+'/1/',auth=self.auth) result=r.json() self.assertEqual(result['username'],'sutune') self.assertEqual(result['email'],'sutune@163.com') # @unittest.skip('skip add user') def test_002_add_user(self): form_data={'id':3,'username':'zxw666','email':'zxw666@qq.com','groups':'http://127.0.0.1:8000/groups/2/'} r=requests.post(self.base_url+'/',data=form_data,auth=self.auth) result=r.json() self.assertEqual(result['username'],'zxw666') # @unittest.skip('skip test_delete_user') def test_003_delete_user(self): r=requests.delete(self.base_url+'/2/',auth=self.auth) self.assertEqual(r.status_code,204) def test_004_update_user(self): form_data={'email':'zxw2018@163.com'} r=requests.patch(self.base_url+'/1/',auth=self.auth,data=form_data) result=r.json() self.assertEqual(result['email'],'zxw2018@163.com') def test_005_no_auth(self): r=requests.get(self.base_url) result=r.json() self.assertEqual(result['detail'],'Authentication credentials were not provided.') class GroupTest(unittest.TestCase): def setUp(self): self.base_url='http://127.0.0.1:8000/groups' self.auth=('51zxw','zxw20182018') def test_001_group_developer(self): r=requests.get(self.base_url+'/1/',auth=self.auth) result=r.json() self.assertEqual(result['name'],'Developer') def test_002_add_group(self): form_data={'name':'Pm'} r=requests.post(self.base_url+'/',auth=self.auth,data=form_data) result=r.json() self.assertEqual(result['name'],'Pm') def test_003_update_group(self): form_data={'name':'Boss'} r=requests.patch(self.base_url+'/2/',auth=self.auth,data=form_data) result=r.json() self.assertEqual(result['name'],'Boss') def test_004_detele_group(self): r=requests.delete(self.base_url+'/1/',auth=self.auth) self.assertEqual(r.status_code,204) if __name__ == '__main__': db=DB() f = open('datas.yaml', 'r') datas = yaml.load(f) db.init_data(datas) unittest.main() 这样每次迭代回归测试就不用担心数据环境相互干扰的问题了。 执行用例&测试报告 在 test_project 目录下面创建 reports 目录，然后新建 run.py 模块。 import unittest from BSTestRunner import BSTestRunner from mysql_action import DB import time import yaml #数据初始化操作 db=DB() f = open('datas.yaml', 'r') datas = yaml.load(f) db.init_data(datas) #指定测试用例和测试报告的路径 test_dir = '.' report_dir = './reports' #加载测试用例 discover = unittest.defaultTestLoader.discover(test_dir, pattern='test_django_restful.py') #定义报告的文件格式 now = time.strftime(\"%Y-%m-%d %H_%M_%S\") report_name = report_dir + '/' + now + ' test_report.html' #运行用例并生成测试报告 with open(report_name, 'wb') as f: runner = BSTestRunner(stream=f, title=\" API Test Report\", description=\"Django Restful Api Test Report\") runner.run(discover) 最后生成的测试报告如下： 日志配置 在自动化测试项目中，日志是非常重要的一个部分，特别是当运行出现错误时，需要查看日志来分析定位解决问题。在 test_project 目录下面创建日志配置文件 log.conf 下面日志配置文件，定义的日志的输出格式，输出路径等信息。然后创建文件夹 logs 存放日志信息。 [loggers] keys=root,infoLogger [logger_root] level=DEBUG handlers=consoleHandler,fileHandler [logger_infoLogger] handlers=consoleHandler,fileHandler qualname=infoLogger propagate=0 [handlers] keys=consoleHandler,fileHandler [handler_consoleHandler] class=StreamHandler level=INFO formatter=form02 args=(sys.stdout,) [handler_fileHandler] class=FileHandler level=INFO formatter=form01 args=('./logs/runlog.log', 'a') [formatters] keys=form01,form02 [formatter_form01] format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s [formatter_form02] format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s 扩展资料: Appium 教程 5-6~5-10 在 run.py 引入配置文件 import unittest from BSTestRunner import BSTestRunner import time,yaml from mysql_action import DB import logging.config #引入日志配置文件 CON_LOG='log.conf' logging.config.fileConfig(CON_LOG) logging=logging.getLogger() #初始化数据 db=DB() f=open('datas.yaml','r') datas=yaml.load(f) db.init_data(datas) test_dir='.' report_dir='./reports' discover=unittest.defaultTestLoader.discover(test_dir,pattern='test_django_restful.py') now=time.strftime('%Y-%m-%d %H_%M_%S') report_name=report_dir+'/'+now+' test_report.html' with open (report_name,'wb') as f: runner=BSTestRunner(stream=f,title='API Test Report',description='Django Restful API Test Report') logging.info('============API Test================') runner.run(discover) 在 mysql_action.py 添加日志 from pymysql import connect import yaml import logging class DB(): def __init__(self): logging.info('=============init data=================') logging.info('connect db...') self.conn=connect(host='127.0.0.1',user='root',password='',db='django_restful') def clear(self,table_name): logging.info('clear db...') clear_sql='truncate '+table_name+';' with self.conn.cursor() as cursor: cursor.execute('set foreign_key_checks=0;') cursor.execute(clear_sql) self.conn.commit() def insert(self,table_name,table_data): for key in table_data: table_data[key]=\"'\"+str(table_data[key])+\"'\" key=','.join(table_data.keys()) value=','.join(table_data.values()) logging.info(key) logging.info(value) insert_sql='insert into '+table_name+'('+key+')'+'values'+'('+value+')' logging.info(insert_sql) with self.conn.cursor() as cursor: cursor.execute(insert_sql) self.conn.commit() def close(self): logging.info('close db') self.conn.close() logging.info('==============init data finished!=============') def init_data(self,datas): for table,data in datas.items(): self.clear(table) for d in data: self.insert(table,d) self.close() if __name__ == '__main__': db=DB() # db.clear('api_user') # db.clear('api_group') # user_data={'id':1,'username':'zxw2018','email':'zxw2018@163.com'} # db.insert('api_user',user_data) # db.close() f=open('datas.yaml','r') datas=yaml.load(f) db.init_data(datas) 最后在 test_django_restful.py 添加日志。 import requests import unittest from mysql_action import DB import yaml import logging class UserTest(unittest.TestCase): def setUp(self): self.base_url='http://127.0.0.1:8000/users' self.auth=('51zxw','zxw20182018') def test_001_get_user(self): logging.info('test_001_get_user') r=requests.get(self.base_url+'/1/',auth=self.auth) result=r.json() self.assertEqual(result['username'],'sutune') self.assertEqual(result['email'],'sutune@163.com') def test_002_add_user(self): logging.info('test_002_add_user') form_data={'username':'zxw666','email':'zxw666@163.com','groups':'http://127.0.0.1:8000/groups/2/'} r=requests.post(self.base_url+'/',data=form_data,auth=self.auth) result=r.json() self.assertEqual(result['username'],'zxw666') self.assertEqual(result['email'],'zxw666@163.com') def test_003_update_user(self): logging.info('test_003_update_user') form_data={'email':'zxw2018@163.com'} r=requests.patch(self.base_url+'/1/',data=form_data,auth=self.auth) result=r.json() self.assertEqual(result['email'],'zxw2018@163.com') def test_004_delete_user(self): logging.info('test_004_delete_user') r=requests.delete(self.base_url+'/2/',auth=self.auth) self.assertEqual(r.status_code,204) def test_005_no_auth(self): logging.info('test_005_no_auth') r=requests.get(self.base_url) result=r.json() self.assertEqual(result['detail'],'Authentication credentials were not provided.') class GroupTest(unittest.TestCase): def setUp(self): self.base_url='http://127.0.0.1:8000/groups' self.auth=('51zxw','zxw20182018') def test_001_group_developer(self): logging.info('test_001_group_developer') r=requests.get(self.base_url+'/1/',auth=self.auth) result=r.json() self.assertEqual(result['name'],'Developer') def test_002_add_group(self): logging.info('test_002_add_group') form_data={'name':'Pm'} r=requests.post(self.base_url+'/',data=form_data,auth=self.auth) result=r.json() self.assertEqual(result['name'],'Pm') def test_003_update_group(self): logging.info('test_003_update_group') form_data={'name':'Boss'} r=requests.patch(self.base_url+'/2/',data=form_data,auth=self.auth) result=r.json() self.assertEqual(result['name'],'Boss') def test_004_delete_group(self): logging.info('test_004_delete_group') r=requests.delete(self.base_url+'/1/',auth=self.auth) self.assertEqual(r.status_code,204) if __name__ == '__main__': db=DB() f=open('datas.yaml','r') datas=yaml.load(f) db.init_data(datas) unittest.main() 运行完成之后可以在 logs 目录里面看到如下 log： 2018-08-20 11:25:57,456 mysql_action.py[line:7] INFO =============init data================= 2018-08-20 11:25:57,456 mysql_action.py[line:8] INFO connect db... 2018-08-20 11:25:57,465 mysql_action.py[line:12] INFO clear db... 2018-08-20 11:25:57,469 mysql_action.py[line:26] INFO email,username,id,groups 2018-08-20 11:25:57,469 mysql_action.py[line:27] INFO 'sutune@163.com','sutune','1','http://127.0.0.1:8000/groups/1/' 2018-08-20 11:25:57,470 mysql_action.py[line:30] INFO insert into api_user(email,username,id,groups)values('sutune@163.com','sutune','1','http://127.0.0.1:8000/groups/1/') 2018-08-20 11:25:57,471 mysql_action.py[line:26] INFO email,username,id,groups 2018-08-20 11:25:57,471 mysql_action.py[line:27] INFO '51zxw@163.com','51zxw','2','http://127.0.0.1:8000/groups/2/' 2018-08-20 11:25:57,473 mysql_action.py[line:30] INFO insert into api_user(email,username,id,groups)values('51zxw@163.com','51zxw','2','http://127.0.0.1:8000/groups/2/') 2018-08-20 11:25:57,473 mysql_action.py[line:12] INFO clear db... 2018-08-20 11:25:57,477 mysql_action.py[line:26] INFO name,id 2018-08-20 11:25:57,477 mysql_action.py[line:27] INFO 'Developer','1' 2018-08-20 11:25:57,477 mysql_action.py[line:30] INFO insert into api_group(name,id)values('Developer','1') 2018-08-20 11:25:57,478 mysql_action.py[line:26] INFO name,id 2018-08-20 11:25:57,478 mysql_action.py[line:27] INFO 'Tester','2' 2018-08-20 11:25:57,479 mysql_action.py[line:30] INFO insert into api_group(name,id)values('Tester','2') 2018-08-20 11:25:57,479 mysql_action.py[line:37] INFO close db 2018-08-20 11:25:57,479 mysql_action.py[line:39] INFO ==============init data finished!============= 2018-08-20 11:25:57,658 run.py[line:28] INFO ============API Test================ 2018-08-20 11:25:57,659 test_django_restful.py[line:60] INFO test_001_group_developer 2018-08-20 11:25:57,783 test_django_restful.py[line:67] INFO test_002_add_group 2018-08-20 11:25:57,903 test_django_restful.py[line:75] INFO test_003_update_group 2018-08-20 11:25:58,009 test_django_restful.py[line:83] INFO test_004_delete_group 2018-08-20 11:25:58,106 test_django_restful.py[line:14] INFO test_001_get_user 2018-08-20 11:25:58,211 test_django_restful.py[line:22] INFO test_002_add_user 2018-08-20 11:25:58,309 test_django_restful.py[line:32] INFO test_003_update_user 2018-08-20 11:25:58,405 test_django_restful.py[line:40] INFO test_004_delete_user 2018-08-20 11:25:58,496 test_django_restful.py[line:46] INFO test_005_no_auth 集成 Jenkins 使用 Jenkins 持续集成平台我们可以自动定时执行自动化任务，自动发送邮件推送测试报告，这样会有效提高自动化测试执行效率。 打开 Jenkins 创建项目 django_restful_api 然后在构建中选择 \"执行 Windows 批处理\" 填入如下内容： d: cd D:\\django_restful\\api\\test_project C:\\Python35\\python.exe run.py 执行完成后可以查看到控制台输出 最后在对应的报告文件夹可以看到生成对应的测试报告。 Jenkins 定时构建语法 * * * * * (五颗星，中间用空格隔开） • 第一个表示分钟，取值 0~59 • 第二个表示小时，取值 0~23 • 第三个表示一个月的第几天，取值 1~31 • 第四个表示第几月，取值 1~12 • 第五个*表示一周中的第几天，取值 0~7，其中 0 和 7 代表的都是周日 使用案例 每天下午 18 点定时构建一次 0 18 * * 1-5 每天早上 8 点构建一次 0 8 * * * 每 30 分钟构建一次： H/30 * * * * Python 邮件发送 参考资料：Selenium 教程 7-1~7-4 参考资料 • http://www.runoob.com/python/python-mysql.html • https://baike.baidu.com/item/navicat/3089699?fr=aladdin • https://baike.baidu.com/item/mySQL/471251 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第三章/Locust接口性能测试.html":{"url":"第三章/Locust接口性能测试.html","title":"第5节：Locust接口性能测试","keywords":"","body":"第5节：Locust接口性能测试 性能测试工具 谈到性能测试工具，我们首先想到的是 LoadRunner 或 JMeter。 LoadRunner 是非常有名的商业性能测试工具， 功能非常强大。但现在一般不推荐使用该工具来进行性能测试，主要是使用也较为复杂，而且该工具体积比较大， 需要付费且价格不便宜。 关于 LoadRunner 使用教程见：LoadRunner 性能测试入门教程 JMeter 同样是非常有名的开源性能测试工具，功能也很完善，我们之前介绍了它作为接口测试工具的使用。 Locust 同样是性能测试工具，虽然官方这样来描述它：“An open source load testing tool.”，但它和前面两个 工具有一些不同。 Locust 简介 Locust 完全基于 Python 编程语言，采用纯 Python 描述测试脚本，并且 HTTP 请求完全基于 Requests 库。除了HTTP/HTTPS 协议外，Locust 还可以测试其他协议的系统，只需采用 Python 调用对应的库进行请求描述即可。LoadRunner 和 JMeter 这类采用进程和线程的测试工具，都很难在单机上模拟出较高的并发压力。Locust 的并发机制摒弃了进程和线程，采用协程（gevent）的机制。协程避免了系统级资源调度，因此可以大幅提高单机的并发能力。 扩展资料：协程—廖雪峰博客 下载安装 官网地址：https://www.locust.io 使用 pip 命令安装 Locust： pip install locustio 安装完成之后检测是否安装成功： 测试案例 测试场景 针对如下两个接口进行性能测试： http://127.0.0.1:8000/users/ http://127.0.0.1:8000/groups/ 以上两个接口也就是我们之前项目 django_restful 的接口 负载场景 • 每秒生成 2 个用户，总共生成 60 个用户。 • 负载测试 5 分钟然后查看接口的平均响应时间。 脚本实现 restful_api_locust.py from locust import HttpLocust,TaskSet,task class UserBehavior(TaskSet): @task(2) def test_users(self): self.client.get(\"/users/\",auth=('51zxw','zxw20182018')) @task(1) def test_groups(self): self.client.get(\"/groups/\",auth=('51zxw','zxw20182018')) class WebsiteUser(HttpLocust): task_set = UserBehavior min_wait = 3000 max_wait = 6000 UserBehavior 类继承 TaskSet 类，用于描述用户行为。 • @task 装饰该方法为一个事务,后面的数字表示请求比例，上面的比例为 2:1 默认都是 1:1 • test_users()方法表示一个用户行为，这里是请求 user 接口。 • test_groups()方法表示请求 group 接口。 • client.get()用于指定请求的路径。 WebsiteUser 类用于设置性能测试。 • task_set：指向一个定义的用户行为类。 • min_wait：执行事务之间用户等待时间的下界（单位：毫秒）。 • max_wait：执行事务之间用户等待时间的上界（单位：毫秒）。 执行测试 使用如下命令开始启动测试 C:\\Users\\Shuqing>locust -f D:\\api_test\\locust\\restful_api_locust.py --host=http://127.0.0.1:8000 [2018-07-24 15:39:22,917] LAPTOP-8B5JADC8/INFO/locust.main: Starting web monitor at *:8089 [2018-07-24 15:39:22,917] LAPTOP-8B5JADC8/INFO/locust.main: Starting Locust 0.8.1 在浏览器打开 localhost:8089 可以看到如下页面： • Number of users to simulate：设置模拟用户数。 • Hatch rate（users spawned/second）：每秒产生（启动）的虚拟用户数。 • 单击“Start swarming”按钮，开始运行性能测试 运行之后可以看到主界面如下： 性能测试参数如下。 • Type：请求的类型，例如 GET/POST。 • Name：请求的路径。 • request：当前请求的数量。 • fails：当前请求失败的数量。 • Median：中间值，单位毫秒，一半的服务器响应时间低于该值，而另一半高于该值。 • Average：平均值，单位毫秒，所有请求的平均响应时间。 • Min：请求的最小服务器响应时间，单位毫秒。 • Max：请求的最大服务器响应时间，单位毫秒。 • Content Size：单个请求的大小，单位字节。 • reqs/sec：每秒钟请求的个数。 点击 Charts 菜单可以查看性能图表 图表含义如下： • Total Request per Second ：每秒的请求数 • Average Response Time: 平均响应时间 • Number of Users: 用户数 参数化 测试场景 如果想对如下接口进行并发测试，则可以将 id 进行参数化设置 http://127.0.0.1:8000/groups/1/ http://127.0.0.1:8000/groups/2/ http://127.0.0.1:8000/users/1/ http://127.0.0.1:8000/users/2/ 代码实现 locust_users_groups.py from locust import HttpLocust,TaskSet,task class UserBehavior(TaskSet): def on_start(self): #设置 user 和 group 参数下标初始值 self.users_index=0 self.groups_index=0 @task def test_users(self): #读取参数 users_id=self.locust.id[self.users_index] url=\"/users/\"+str(users_id)+'/' self.client.get(url,auth=('51zxw','zxw20182018')) #取余运算循环遍历参数 self.users_index=(self.users_index+1)%len(self.locust.id) @task def test_groups(self): #参数化 groups_id=self.locust.id[self.groups_index] url=\"/groups/\"+str(groups_id)+\"/\" self.client.get(url,auth=('51zxw','zxw20182018')) self.groups_index=(self.groups_index+1)%len(self.locust.id) class WebsiteUser(HttpLocust): task_set = UserBehavior #参数配置 id=[1,2] min_wait = 3000 max_wait = 6000 #host 配置 host = 'http://127.0.0.1:8000' 运行结果 执行如下命令即可运行测试 运行模式 no-web 运行 前面是通过登录 web 来运行测试的，其实也可以非 web 状态来运行,如 cmd 命令来运行。 如果需要非 Web 形式运行，则需使用--no-web 参数，并会用到如下几个参数。 • -c, --clients：指定并发用户数； • -r, --hatch-rate：指定并发加压速率，默认值位 1。 • -t, --run-time：设置运行时间。如(300s,20m, 3h, 1h30m 等）； 运行命令如下： locust -f D:\\api_test\\locust\\locust_users_groups.py --no-web -c 10 -r 2 -t 15s 运行结果如下： 分布式运行 上面我们都是单台机器来执行性能测试，但是当单台机器不够模拟足够多的用户时，Locust 支持运行在多台机器 中进行压力测试。分布式运行一般是一台 master 多台 slave 如下图所示： 首先定义一台 master C:\\Users\\Shuqing>locust -f D:\\api_test\\locust\\locust_users_groups.py --master 然后定义 slave C:\\Users\\Shuqing>locust -f D:\\api_test\\locust\\locust_users_groups.py --slave 如果 slave 与 master 不在同一台机器上，还需要通过--master-host 参数再指定 master 的 IP 地址。 C:\\Users\\Shuqing>locust -f D:\\api_test\\locust\\locust_users_groups.py --slave -- master-host 运行之后可以看到 web 界面显示的 SLAVES 数量 本章小结 内容概要 • Restful 接口概述 • Django 安装配置 • Django Restful 接口开发 • Restful 接口测试(测试工具&Requests+unittest) • 接口测试数据管理(数据初始化封装) • Swagger 接口文档 • 日志配置 • 集成 Jenkins • Locuts 接口性能测试 学习建议 多找一些不同类型的接口来进行练习。推荐接口平台如下： • 聚合数据 • 极速数据 • 万维易源 参考资料 • https://docs.locust.io/en/stable/quickstart.html • http://debugtalk.com/post/head-first-locust-user-guide/ By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第三章/Mock利器——Json Server.html":{"url":"第三章/Mock利器——Json Server.html","title":"第6节：Mock利器——Json Server","keywords":"","body":"第6节：Mock利器——Json Server 什么是 Mock Mock 在中文的含义就是模拟的意思，mock 测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。 简单来说，就是通过某种技术手段模拟测试对象的行为，返回预先设计的结果。这里的关键词是预先设计，也就是说对于任意被测试的对象，可以根据具体测试场景的需要，返回特定的结果。比如要测试支付，但是你不想真实支付，那么可以 Mock 来模拟支付，返回支付的结果。 Mock 作用 • 首先，Mock 可以用来解除测试对象对外部服务的依赖（比如数据库，第三方接口等），使得测试用例可以独立运行。 • 提前创建测试，TDD（测试驱动开发）。如果你创建了一个 Mock 那么你就可以在接口开发完成之前写接口测试脚本了，当接口开发完成时再替换为真实的接口进行测试即可。 • 替换外部服务调用，提升测试用例的运行速度。任何外部服务调用至少是跨进程级别的消耗，甚至是跨系统、跨网络的消耗，而 Mock 可以把消耗降低到进程内。 Json Server 简介 json-server 是一款小巧的 Mock 工具，它可以不写一行代码在 30 秒内创建一套 Restful 风格的 api，适合 3 人及以下的前端团队做迅速 mock 后台逻辑，也可以在接口测试中使用。相比较 Django，flask 来实现 Mock 要方便很多。 • 主页地址：https://www.npmjs.com/package/json-server • Github 项目地址：https://github.com/typicode/json-server Json Server 下载安装 环境依赖 • 首选需要安装好 Node.js, • 国内用户建议配置好：cnpm • 安装配置视频教程可参考：Appium 环境搭建 安装 cnpm install -g json-server 校验 安装完成后输入如下命令进行校验： json-server -h 安装正确会提示如下内容： 入门使用 创建 data 文件 首先创建一个 json 文件：db.json 内容如下： { \"posts\": [ { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" } ], \"comments\": [ { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 } ], \"profile\": { \"name\": \"typicode\" } } 启动服务 C:\\Users\\Shuqing>json-server --watch D:\\api_test\\json_action\\db.json 启动成功后可以看到如下提示： 接口测试 在浏览器输入 http://localhost:3000 可以进入到主页。 查询 输入 http://localhost:3000/posts 可以查看到对应的返回值： [ { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" } ] 输入 http://localhost:3000/posts/1 可以查看到如下返回值： { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" } 增加 使用 POST 请求可以增加数据，例如我们在 Postman 中进行如下配置 可以看到成功插入了数据。 修改 使用 PATCH 或者 PUT 可以对数据更新，例如如下配置，即可修改 author 数据。 删除 使用 DELETE 可以删除数据，例如 请求 http://NaN/posts/3，则会删除 id=3 的数据 路由生成 根据上面的 data 文件，默认情况下 json-server 会生成两类路由： 复数路由 单数路由 接口调试 首先创建 db.json 数据内容如下： { \"posts\": [ { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }, { \"id\": 2, \"title\": \"zxw\", \"author\": \"sutune\" }, { \"id\": 3, \"title\": \"zxw666\", \"author\": {\"name\":\"jack\"} }, { \"id\": 4, \"title\": \"zxw888\", \"author\": \"Bob\" } ], \"comments\": [ { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }, { \"id\": 2, \"body\": \"hello 51zxw\", \"postId\": 2 }, { \"id\": 3, \"body\": \"hello zxw2018\", \"postId\": 3 } ], \"profile\": { \"name\": \"typicode\" } } 过滤 使用查询字符串参数（Query String Parameters）可以查询对应的数据 GET /posts?id=1&id=2 GET /posts?title=zxw 指定过滤字段，使用.号可以查询更深层次属性 GET /posts?author.name=jack 详见视频操作演示 分页 分页也是常用功能，使用_page 指定第几页，_limit 指定返回的数据条数。默认是一页显示 10 条数据。 GET /posts?_page=1 GET /posts?_page=1&_limit=2 排序 _sort 表示排序字段，_order 表示具体的排序方式，默认是升序:asc 降序为：desc。 GET /posts?_sort=id&_order=asc #升序 GET /posts?_sort=id&_order=desc #降序 多字段组合排序 GET /posts?_sort=para1,para2&_order=desc,asc 切片 切片与字符串数组切片类似，可以返回指定范围长度的数据内容，起始下标为 0 • _start 指定纪录起始点，包含起点 • _end 指定终点，不包含终点 • _limit 指定返回的数量 GET /posts?_start=0&_end=3 GET /comments?_start=0&_end=2 GET /posts?_start=0&_limit=2 操作 • _gte: 大于 • _lte: 小于 • _ne: 不等于 • _like: 有点像 sql 的 like，支持正则表达式 GET /posts?id_gte=2&id_lte=3 GET /posts?id_ne=3 GET /posts?title_like=zxw 全局搜索 使用 q 参数，比如 GET /comments?q=zxw 查看 db GET /db 参考资料 • https://baike.baidu.com/item/mock 测试/5300937?fr=aladdin • https://blog.csdn.net/eMac/article/details/71056826 • https://www.npmjs.com/package/json-server • http://www.testclass.net/json_server/query/ By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第三章/HttpRunner接口自动化测试框架.html":{"url":"第三章/HttpRunner接口自动化测试框架.html","title":"第7节：HttpRunner接口自动化测试框架","keywords":"","body":"第7节：HttpRunner接口自动化测试框架 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第四章/":{"url":"第四章/","title":"第四章","keywords":"","body":"第四章 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "},"第四章/接口测试面试题.html":{"url":"第四章/接口测试面试题.html","title":"第1节：接口测试面试题","keywords":"","body":"第1节：接口测试面试题 题 1. 什么是接口测试？ 2. 接口自动化测试的流程是什么？ 3. GET 请求和 POST 请求区别是什么？ 4. 接口测试的常用工具有哪些？ 5. HTTP 接口的请求参数类型有哪些？ 6. 如何从上一个接口获取相关的响应数据传递到下一个接口？ 7. 接口测试用例的编写要点有哪些？ 8. 接口测试的步骤有哪些？ 9. 接口测试中依赖登录状态的接口如何测试？ 10. 依赖于第三方数据的接口如何进行测试？ 参考答案 1、什么是接口测试？ • 接口测试是测试系统组件间接口的一种测试方法。 • 接口测试的重点是检查数据的交换，传递的正确性，以及接口间逻辑依赖关系。 • 提交接口测试的重要意义：实现开发期并行测试，减少页面层测试的深度，缩短整个项目的测试周期。 2、接口自动化测试的流程？ • 基本的接口功能自动化测试流程为： 需求分析 -> 用例设计 -> 脚本开发 -> 测试执行 -> 结果分析 3、GET 请求和 POST 请求区别是什么？ • GET 请求用于信息获取,而且应该是安全的和幂等的；在做数据查询时，建议用 Get 方式。如：商品信息接 口、搜索接口、博客访客接口等。 • POST 请求表示可能会修改服务器上资源的请求；在做数据添加、修改时，建议用 Post 方式 。如：微博 贴吧上传图片接口、登录注册接口等。 Tips： “GET 是从服务器上获取数据，POST 是向服务器传送数据”。这个说法是有误的，GET/POST 都可以提交数据， Get 请求也可以向服务器传递数据，Post 请求也需要服务器返回数据。 4、接口测试的常用工具有哪些？ • Postman • Jmeter • SoapUI 5、HTTP 接口的请求参数类型有哪些？ • 查询字符串参数(Query String Parameters),参数会以 url string 的形式进行传递。 • 请求体参数(Request body)一般用于 POST 请求，可以使用 Content-Type 来指定不同参数类型。 6、如何从上一个接口获取相关的响应数据传递到下一个接口？ • 先从上一个接口中的响应数据获取对应的返回值，然后使用正则表达式或者 json 解析来提取要获取的值， 然后存储在一个变量中，最后在下一个接口中直接引用即可。 7、接口测试用例的编写要点有哪些？ • 请求参数必填项、可选项等 • 输入输出合法、非法参数等 • 请求参数边界值等 • 响应数据校验 • 接口之间逻辑校验，如果两个请求有严格的先后顺序，需要测试调转顺序的情况 8、接口测试的步骤有哪些？ • 发送接口请求 • 测试接口获取的返回值 • 断言：判断实际结果是否与预期相同 9、接口测试中依赖登录状态的接口如何测试？ • 依赖登录状态的接口的本质上是在每次发送请求时需要带上 Session 或者 Cookie 才能发送成功，在构建 POST 请求时添加必要的 Session 或者 Cookie 10、依赖于第三方数据的接口如何进行测试？ • 可以利用一些 MOCK 的工具(如 Json Server,Easy Mock)来模拟第三方的数据返回，最大限度的降低对第 三方数据接口的依赖。 By monster，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-02-11 05:48:40 "}}